\PassOptionsToPackage{binary-units=true}{siunitx}

\documentclass[pl,12pt]{aghdpl}
% \documentclass[en,11pt]{aghdpl}  % praca w języku angielskim

% Lista wszystkich języków stanowiących języki pozycji bibliograficznych użytych w pracy.
% (Zgodnie z zasadami tworzenia bibliografii każda pozycja powinna zostać utworzona zgodnie z zasadami języka, w którym dana publikacja została napisana.)
\usepackage[english,polish]{babel}

% Użyj polskiego łamania wyrazów (zamiast domyślnego angielskiego).
\usepackage{polski}

\usepackage[utf8]{inputenc}

\usepackage[T1]{fontenc}

% Załączniki

\usepackage[toc, page]{appendix}
\renewcommand\appendixpagename{Załączniki}
\renewcommand\appendixtocname{Załączniki}

% dodatkowe pakiety

\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{float}% do umieszczenia floatów [h]
\usepackage{enumitem}
\setlist{nosep} % or \setlist{noitemsep} to leave space around whole list
\usepackage[bookmarks]{hyperref}

% floaty w sekcji w które są stworzone

\usepackage{placeins}

\let\Oldchapter\chapter
\renewcommand{\chapter}{\FloatBarrier\Oldchapter}

\let\Oldsection\section
\renewcommand{\section}{\FloatBarrier\Oldsection}

\let\Oldsubsection\subsection
\renewcommand{\subsection}{\FloatBarrier\Oldsubsection}

\let\Oldsubsubsection\subsubsection
\renewcommand{\subsubsection}{\FloatBarrier\Oldsubsubsection}

% specjalistyczne pakiety

\usepackage{dirtree}% Drzewo folderów
\usepackage[full]{textcomp}% Symbole trademark, registered...

% --- < bibliografia > --


\usepackage[
style=numeric,
sorting=none,
% 
% Zastosuj styl wpisu bibliograficznego właściwy językowi publikacji.
language=autobib,
autolang=other,
% Zapisuj datę dostępu do strony WWW w formacie RRRR-MM-DD.
urldate=edtf,
seconds=true,
% Nie dodawaj numerów stron, na których występuje cytowanie.
backref=false,
% Podawaj ISBN.
isbn=true,
% Nie podawaj URL-i, o ile nie jest to konieczne.
url=false,
% 
% Ustawienia związane z polskimi normami dla bibliografii.
maxbibnames=3,
% Jeżeli używamy Bibera:
backend=biber
]{biblatex}

\usepackage{csquotes}
% Ponieważ `csquotes` nie posiada polskiego stylu, można skorzystać z mocno zbliżonego stylu chorwackiego.
\DeclareQuoteAlias{croatian}{polish}

\addbibresource{bibliografia.bib}

% Nie wyświetlaj wybranych pól.
% \AtEveryBibitem{\clearfield{note}}


% ------------------------
% --- < listingi > ---

% Użyj czcionki kroju Times.
\usepackage{newtxtext}
\usepackage{newtxmath}

\usepackage{listings}
\lstloadlanguages{MATLAB}

\lstset{%
  literate={ą}{{\k{a}}}1
  {ć}{{\'c}}1
  {ę}{{\k{e}}}1
  {ó}{{\'o}}1
  {ń}{{\'n}}1
  {ł}{{\l{}}}1
  {ś}{{\'s}}1
  {ź}{{\'z}}1
  {ż}{{\.z}}1
  {Ą}{{\k{A}}}1
  {Ć}{{\'C}}1
  {Ę}{{\k{E}}}1
  {Ó}{{\'O}}1
  {Ń}{{\'N}}1
  {Ł}{{\L{}}}1
  {Ś}{{\'S}}1
  {Ź}{{\'Z}}1
  {Ż}{{\.Z}}1
}

\usepackage{color}

% --- < kolorowanie kodu > ---

% From overleaf.com
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},     % choose the background color
  basicstyle=\ttfamily\footnotesize, % size of fonts used for the code
  breaklines, breakatwhitespace,     % automatic line breaking only at whitespace
  commentstyle=\color{mygreen},      % comment style
  numbers=left,
  showstringspaces=false,
  numberstyle=\tiny,
  frame=l,
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  keywordstyle=\color{blue},         % keyword style
  stringstyle=\color{mymauve}        % string literal style
}

%%
%% Julia definition (c) 2014 Jubobs
%%
\lstdefinelanguage{Julia}%
  {morekeywords={abstract,break,case,catch,const,continue,do,else,elseif,%
      end,export,false,for,function,immutable,import,importall,if,in,%
      macro,module,otherwise,quote,return,switch,true,try,type,typealias,%
      using,while,begin},%
   sensitive=true,%
   alsoother={$},%$
   morecomment=[l]\#,%
   morecomment=[n]{\#=}{=\#},%
   morestring=[s]{"}{"},%
   morestring=[m]{'}{'},%
}[keywords,comments,strings]%

% ------------------------

\AtBeginDocument{
  \renewcommand{\tablename}{Tab.}
  \renewcommand{\figurename}{Rys.}
}

% ------------------------
% --- < tabele > ---

\usepackage{array}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage[flushleft]{threeparttable}

% defines the X column to use m (\parbox[c]) instead of p (`parbox[t]`)
\newcolumntype{C}[1]{>{\hsize=#1\hsize\centering\arraybackslash}X}

% --------------------------Ustawienia Knitr---------------------------------

<<Opcje globalne, include=FALSE>>=
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
knitr::opts_knit$set(concordance = TRUE);

Sys.setlocale(category = 'LC_ALL','en_US.UTF-8')
Sys.setenv(LANG="EN")
Sys.setlocale("LC_TIME","C")
@ 

%--------------------------Funkcje------------------------------------------

<<Funkcje>>=
library(h5)
library(ggplot2)
library(reshape2)
library(dplyr)

packages <- c("julia","octave","matlab","python","scilab")
tests <- c("sin", "conv", "fft", "four1", "wavread")

rowMax <- function(x, shaveoffpercent=5) {
    apply(x, 1, function(e) {
        max(shaveoff(e, shaveoffpercent), na.rm=TRUE)
    })
}

rowMin <- function(x) {
    apply(x, 1, function(e) {
        min(e, na.rm=TRUE)
    })
}

rowMedian <- function(x) {
    apply(x, 1, function(e) {
        median(e, na.rm=TRUE)
    })
}

rowCountNA  <- function(x) {
    apply(x, 1, function(e) {
        sum(is.na(e))/length(e)
    })
}

shaveoff  <- function(vec, percent) {
    vec[-tail(order(vec), floor(percent*length(vec)/100))]
}

getResults <- function(h5df_file) {
    results <- list()
    for (test_name in tests) {
        results[[test_name]] <- list()
        max_input_size <- length(list.datasets(h5df_file[test_name]["octave"]))
        for (package in packages) {
            number_of_tests  <- length(h5df_file[test_name][package]["1"][])
            results[[test_name]][[package]] <- matrix(NA,max_input_size,number_of_tests)
            for (input_size in 1:max_input_size) {
                res <- as.vector(h5df_file[test_name][package][toString(input_size)][])
                results[[test_name]][[package]][input_size,1:length(res)] <- res
            }
        }
    }
    results
}

preparePlot <- function(res) {
    means <- lapply(res, rowMedian)
    mins <- lapply(res, rowMin)
    maxs <- lapply(res, rowMax)

    means.molten <- as.data.frame(melt(means) %>% group_by(L1) %>% mutate(id = row_number()))
    mins.molten <- as.data.frame(melt(mins) %>% group_by(L1) %>% mutate(id = row_number()))
    maxs.molten <- as.data.frame(melt(maxs) %>% group_by(L1) %>% mutate(id = row_number()))

    means.molten["VectorSize"] <- 10^means.molten["id"]

    plot <- ggplot(means.molten, aes(x=VectorSize, y=value, colour=L1)) 
    plot <- plot + geom_errorbar(aes(ymin=mins.molten["value"], ymax=maxs.molten["value"]), width=.1)
    plot <- plot + scale_y_log10() + scale_x_log10() + geom_point() + geom_line()
    plot <- plot + xlab("Ilo\\'s\\'c element\\'ow wektora wej\\'sciowego")
    plot <- plot + ylab("Czas wykonywania procedury [$\\si{\\second}$]")
    plot <- plot + labs(colour="Pakiet obliczeniowy")
    plot <- plot + theme_bw() + theme(legend.position=c(0.01,0.99), legend.justification=c(0.01,0.99))
    plot
}

summaryMelt <- function(res, func) {
    as.data.frame(melt(lapply(res, function(package) {
        melt(lapply(package, function(x) {
            fff <- func(x)
            tens <- 10^(1:length(fff))
            sum(fff*tens)/sum(tens)
        }))
    })) %>% group_by(L1) %>% mutate(id = packages[row_number()]))
}

summaryPlot <- function(res) {
    sumres <- summaryMelt(res, rowMedian)
    summax <- summaryMelt(res, rowMax)
    summin <- summaryMelt(res, rowMin)

    plot <- ggplot(sumres, aes(x=L1, y=value, colour=id)) 
    plot <- plot + geom_point() + theme_bw() + scale_y_sqrt()
    plot <- plot + geom_errorbar(aes(ymin=summin["value"], ymax=summax["value"]), width=.1)
    plot <- plot + ylab("Czas wykonywania procedury [$\\si{\\second}$]")
    plot <- plot + xlab("Testowana funkcja")
    plot <- plot + labs(colour="Pakiet obliczeniowy")
    plot
}

percentFaster <- function(res, name1, name2) {
    means <- rowMeans(res[[name1]])/rowMeans(res[[name2]])
    tenseq <- 5^(1:length(means))
    round(100 - 100*sum(tenseq)/sum(means*tenseq), 1)
}
@ 
%----------------------------Zmienne----------------------------------------

<<Inicjalizacja zmiennych>>=
author <- "Szymon Mikulicz"
shortAuthor <- paste(substr(author,1,1),'. ',unlist(strsplit(author,'[ ]'))[2],sep='')

results.file <- h5file("../tests/results.amd.h5", "r")
results.amd <- getResults(results.file)
h5close(results.file)

results.file <- h5file("../tests/results.intel.h5", "r")
results.intel <- getResults(results.file)
h5close(results.file)
@ 

%-------------------------Ustawienia TikzDevice---------------------------

<<tikzSettings>>=
options(width=71)
options(digits=7)

require("knitr")

opts_chunk$set(
               keep.source=TRUE,
               out.width='5in',
               fig.width=5,
               fig.height=5/sqrt(2),
               fig.lp="fig:",
               fig.env="figure",
               fig.pos='!htb',
               fig.path='figures-knitr/',  # a unique ID here if you got
               cache.path='cache-knitr/',  # many documents in one dir
               cache=TRUE,
               tidy=FALSE,
               dev='tikz',
               external=TRUE,
               fig.align='center',
               size='small'
           )

options(tikzDefaultEngine = "pdftex")

options(tikzLatexPackages = c(
            "\\usepackage{amsmath,amssymb,amsfonts}",
            "\\usepackage{siunitx}",
            "\\usepackage[utf8]{inputenc}",
            "\\usepackage[english,polish]{babel}",
            "\\selectlanguage{polish}",
            "\\usepackage{tikz}",
            "\\usetikzlibrary{calc}",
            "\\usepackage{standalone}"
        ))

options(tikzMetricsDictionary="~/R/tikzMetrics") # speeds tikz up

options(tikzDocumentDeclaration = "\\documentclass[10pt]{standalone}\n")

options(tikzMetricPackages = c(
            "\\usetikzlibrary{calc}",
            "\\usepackage[utf8]{inputenc}",
            "\\usepackage[english,polish]{babel}",
            "\\selectlanguage{polish}"
        ))


knit_theme$set(knit_theme$get("default"))
@ 

%---------------------------------------------------------------------------

\author{\Sexpr{author}}

\makeatletter%
\@ifclassloaded{aghdpl}{
  \address{Legionów 49, 05-220 Zielonka}
  \sex{m} % Mężczyzna - m; kobieta - cokolwiek
  \shortauthor{\Sexpr{shortAuthor}}
  \albumnum{279253}

  \titlePL{Analiza porównawcza wybranych cech pakietów obliczeniowych w~perspektywie ogólnoakustycznej}
  \titleEN{Comparative analysis of choosen properties of numerical computing environments in the acoustic perspective}

  \shorttitlePL{Porównanie pakietów obliczeniowych w akustyce} % skrócona wersja tytułu jeśli jest bardzo długi
  \shorttitleEN{Comparison of numerical computing environments in acoustics}

  % rodzaj pracy bez końcówki fleksyjnej np. inżyniersk, magistersk
  \thesistypePL{inżyniersk}
  \thesistypeEN{engineer}

  \supervisor{Dr inż. Bartłomiej Borkowski}

  \reviewer{prof. dr hab. inż. Jerzy Wiciak}

  \degreeprogrammePL{Inżynieria Akustyczna}
  \degreeprogrammeEN{Acoustic Engineering}

  \specialisationPL{{[}Nazwa specjalności]}
  \specialisationEN{{[}Specialisation]}

  \graduationyear{2017}
  \years{2017/2018}
  \yearofstudy{IV}

  \department{Katedra Mechaniki i Wibroakustyki}
  % \department{Department of Applied Computer Science}

  \facultyPL{Wydział Inżynierii Mechanicznej i Robotyki}
  \facultyEN{Faculty of Mechanical Engineering and Robotics}

  \thesisplan{ % Przykładowy plan pracy, należy omówić z promotorem
    \begin{enumerate}
    \item Omówienie tematu pracy i sposobu realizacji z promotorem.
    \item Zebranie i opracowanie literatury dotyczącej tematu pracy.
    \item Zebranie i opracowanie wyników badań.
    \item Analiza wyników badań, ich omówienie i zatwierdzenie przez promotora.
    \item Opracowanie redakcyjne.
    \end{enumerate}
  }

  \summaryPL{{[}Treść streszczenia]}
  \summaryEN{{[}Summary text]}

  \acknowledgements{Serdecznie dziękuję \dots tu ciąg dalszych podziękowań np. dla promotora, żony, sąsiada itp.}
  \setlength{\cftsecnumwidth}{10mm}
}{}%
\makeatother%

\date{\today}

%---------------------------------------------------------------------------
\setcounter{secnumdepth}{4}
\brokenpenalty=10000\relax

\begin{document}

\titlepages

% Ponowne zdefiniowanie stylu `plain`, aby usunąć numer strony z pierwszej strony spisu treści i poszczególnych rozdziałów.
\fancypagestyle{plain}
{
  % Usuń nagłówek i stopkę
  \fancyhf{}
  % Usuń linie.
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}
}

\setcounter{tocdepth}{2}
{\singlespacing\tableofcontents}
\clearpage

\chapter{Wprowadzenie i cel pracy}
\label{cha:wstep}

\Sexpr{library("rmsfact"); rmsfact()}\cite{Lam92}

% Odnośniki do umieszczenia w bibl:
% https://docs.anaconda.com/
% https://docs.julialang.org/
% https://www.anaconda.com/enterprise/


\chapter{Badane pakiety obliczeniowe}
\label{cha:pakiety}

Zbadano pięć pakietów, które wybrano szczególnie ze względu na podobieństwo do MATLABa[odnośnik do alternativeto], oraz popularność[TIOBE].  

\section{Anaconda/Python}
\label{sec:anaconda}

\emph{Anaconda Distribution}[odnośnik] to najpopularniejsza dystrybucja jeżyka
programowania \emph{Python} do zastosowań techniczno-naukowych,
zawiera bardzo dużą liczbę pakietów do tych celów, jest dostarczana przez
firmę Anaconda, jest otwartoźródłowa oraz darmowa. \emph{Anaconda Enterprise} jest to
wersja dystrybucji dla klientów biznesowych posiadająca pełne wsparcie
oraz większe możliwości[odnośnik]. W dalszej części pracy \emph{Anaconda Distribution}
będzie nazywana po prostu Anaconda.

Python jest najpopularniejszym językiem programowania wśród języków badanych pakietów,
i znajduje się w pierwszej piątce najpopularniejszych języków na świecie[odnośnik].
Z tego powodu ilość wysokiej jakości bibliotek do tego języka jest niezwykle duża,
także niemalże każda pożądana funkcjonalność może być dodana. Instalacja
bibliotek w Anacondzie odbywa się przy użyciu graficznej aplikacji
\emph{Anaconda Navigator} lub aplikacji wiersza poleceń \emph{conda}.
Używając komendy \lstinline{conda install <nazwa biblioteki>} można zainstalować
bibliotekę z repozytorium Anacondy -- \emph{Anaconda Cloud}. Istnieje również
możliwość instalacji bibliotek z \emph{PyPI}, czyli ogólnego zbioru bibliotek do Pythona 
przy użyciu polecenia \lstinline{pip install <nazwa pakietu>}.


\section{GNU Octave}
\label{sec:octave}

\section{JuliaPro/Julia}
\label{sec:julia}

\section{MATLAB}
\label{sec:matlab}

\section{Scilab}
\label{sec:scilab}

\chapter{Proces badawczy}
\label{chap:probad}

\section{Środowisko badawcze}
\label{sec:srodowisko}

W celu eliminacji wszelkich czynników, który występowanie mogłoby
wpłynąć na wiarygodność wyników przygotowano minimalne środowisko
badawcze na bazie Linuxa z patchem (łatką) CONFIG\_PREEMPT\_RT
(RTLinux), gdzie RT oznacza RealTime (czasu rzeczywistego).
Pozwala on, procesowi o wysokim priorytecie, otrzymać zasoby
komputera (czas procesora, dostęp do RAMu i dysku) w pierwszej
kolejności, przed większością procesów systemowych oraz, co jest
normalnym zachowaniem Linuxa, wszystkimi procesami o niższym
priorytecie[BIBTEX:https://lwn.net/Articles/146861/]. Dzięki temu
można mieć pewność, że żaden proces uruchomiony w tle nie spowoduje
zaniżonych wyników badań. Testy przeprowadzono na dwóch komputerach:
laptopie z ośmiowątkowym procesorem Intel\textregistered\
Core\texttrademark\ piątej generacji oraz komputerze
stacjonarnym z czterowątkowym procesorem AMD z serii 
Phenom\texttrademark\ II w celu porównania wyników na różnych
platformach.

Wykorzystano dystrybucję \emph{Arch Linux}, gdyż posiada ona
RTLinux w repozytoriach użytkowników. Wykorzystana wersja
Linuxa to 4.14.8 z patchem w wersji 9. Wykorzystane wersje
pakietów to:
\begin{itemize}%
\item Anaconda 5.01/Python 3.6.3
\item GNU Octave 4.2.1
\item JuliaPro v0.6.1.1/Julia v0.6.1
\item MATLAB R2017b
\item Scilab 6.0 (Wersja z systemu CI z 29.11.2017)
\end{itemize}%
Są to najnowsze stabilne wersję tych pakietów na dzień 29.11.2017,
poza Scilabem, którego wersja stabilna nie uruchamia się na tej
wersji Linuxa. Jest to problem w wersji 6.0, który nie został
jeszcze naprawiony. Ponadto oficjalne odnośniki do pobrania
wersji \emph{nightly} zwracają błąd 404, toteż jedyną opcją było
pobranie wersji z systemu CI (Continuous Integration -- system
automatycznej kompilacji i testowania kodu). Dodatkowo, jako że
pakiet JuliaPro nie zawiera w sobie biblioteki pozwalającej
odczytywać pliki audio, wykorzystano, wybraną ze względu na
popularność, bibliotekę \emph{WAV.jl} w wersji v0.9.0.

Do zbadania sposobu wykorzystywania zasobów komputera przez procesy 
pakietów obliczeniowych wykorzystano aplikację \emph{htop}, a do
przetwarzania i analizy danych wynikowych testów wykorzystano język
\emph{R}.

\section{System testujący}
\label{sec:systest}

Został napisany automatyczny system testujący pakiety w celu
wygodnego powtarzania testów. Składa się on z skryptu w bashu
(powłoka systemowa w większości systemów opartych na Linuxie),
który zajmuje się uruchamianiem pakietów, interpretuje
przyjmowane argumenty i przekazuje opcje do pakietów, oraz
ze skryptów w każdym z testowanych języków, które uruchamiają
testy, mierzą czas wykonania, po czym zapisują wyniki do pliku.
\begin{table}[h]%
\caption{Kod funkcji \emph{testdir}}%
\lstinputlisting[language=bash, firstline=25, lastline=54]{../tests/test.sh}%
\label{tab:testdir}%
\end{table}%
Najważniejszą częścią skryptu testującego jest funkcja \lstinline{testdir()}
(Tablica \ref{tab:testdir}),
która przyjmuje trzy argumenty: \emph{\$1} -- ścieżka do pakietu
testowanego, \emph{\$2} -- rozszerzenie plików pakietu oraz \emph{\$3} --
nazwa folderu w którym znajdują się testy. Testy muszą znajdywać
się w podfolderach i zawierać się w pliku \emph{test.\$2}. Struktura tego
pliku jest omówiona w punkcie \ref{sec:algo}, natomiast rysunek
\ref{fig:dirstruc} pokazuje jak powinna wyglądać struktura
folderów.
\begin{figure}[h]%
  \centering%
  \begin{minipage}{0.3\textwidth}%
    \dirtree{%
      .1 tests/.
      .2 test.sh.
      .2 matlab/.
      .3 tester.m.
      .3 tests/.
      .4 sin/.
      .5 test.m.
      .4 fft/.
      .5 test.m.
      .4 \dots.
      .2 julia/.
      .3 \dots.
      .2 \dots.
    }%
  \end{minipage}%
  \caption{Struktura folderów systemu testującego}%
  \label{fig:dirstruc}%
\end{figure}%
\begin{table}[h]%
  \caption{Fragment kodu pliku testującego (Julia)}%
  \lstinputlisting[language=Julia, firstline=8, lastline=17]{../tests/julia/tester.jl}%
  \label{tab:tester}%
\end{table}%
Funkcja \lstinline{testdir()} uruchamiana jest dla każdego z pakietów
z odpowiednimi argumentami, ponadto w pliku \emph{test.sh},
znajduje się tablica z globalnymi ustawieniami, które zostaną
zapisane w pliku \emph{options.\$2} i następnie wczytane przez
kod testujący w testowanym języku w pliku \emph{tester.\$2}
(Tab. \ref{tab:tester}). Skrypt \emph{test.sh} można uruchomić
z trzema argumentami, kolejno: nazwa folderu z testami
(nazwa pakietu), nazwa testu (folderu z plikiem \emph{test.\$2})
i maksymalny rząd wielkości ilości elementów wektora wejściowego.
Argumenty pierwszy i drugi przekazywane są do funkcji \lstinline{testdir()} jako
odpowiednio \lstinline{$3} i \lstinline{$TESTARG}, natomiast zmienna
\lstinline{$INPUT_SIZES}%$
zawiera szereg kolejnych potęg liczby dziesięć,
aż do maksymalnego rzędu wielkości ilości elementów wektora wejściowego.
Skrypt uruchamia każdy z pakietów za pomocą komendy \lstinline{chrt},
nadając najwyższy priorytet ich procesom, wszystkie pakiety
uruchamiane są bez interfejsu graficznego w celu zmniejszenia
czasu startowego i pominięcia jego wpływu na wydajność pakietu.
Plik testujący \emph{tester.\$2} pomija wynik pierwszego
testu by uwzględnić \emph{prekompilację} -- w celu przyspieszenia
wykonywania instrukcji część pakietów kompiluje napisany skrypt do
postaci kodu maszynowego, co może powodować nadmiarowo długi czas
wykonywania się skryptu za pierwszym razem. Każde uruchomienie
funkcji testowanej zawarte jest pomiędzy wywołaniami funkcji
mierzących czas systemowy: są to \lstinline{tic()} i \lstinline{toc()}
w MATLABie, GNU Octave i Scilabie, \lstinline{tic()} i
\lstinline{toq()} w Julii, natomiast
w Pythonie wywoływane jest \lstinline{tic=time.time()} i
\lstinline{time.time()-tic}. Po wykonaniu
odpowiedniej ilości testów (ilość ustalana jest w pliku
\emph{test.sh} i następnie przekazywana do pliku \emph{options.\$2}
jako zmienna \lstinline{number_of_tests})
zapisuje wyniki do pliku w formacie HDF5[odnośnik].
Jest to binarny format zapisu danych liczbowych w postaci
macierzy wielowymiarowych, który jest obsługiwany przez
wszystkie pakiety (do GNU Octave wymagana jest dodatkowa
biblioteka \emph{hdf5oct}[odnośnik]) i zawiera informację o strukturze, przypominającej
foldery i pliki. Wynik dla każdego rzędu wielkości zapisany jest
w oddzielnej tablicy, nazwanej numerem oznaczającym rząd wielkości,
w grupie \emph{/<test>/<pakiet>/} (Rys. \ref{fig:h5struc}).
\begin{figure}[h]%
  \centering%
  \begin{minipage}{0.3\textwidth}%
    \dirtree{%
      .1 /.
      .2 sin/.
      .3 matlab/.
      .4 1.
      .4 2.
      .4 \dots.
      .3 julia/.
      .4 \dots.
      .3 \dots.
      .2 fft/.
      .3 \dots.
      .2 \dots.
    }%
  \end{minipage}%
  \caption{Struktura wyników w pliku HDF5}%
  \label{fig:h5struc}%
\end{figure}%

\section{Badane funkcje i algorytmy}
\label{sec:algo}

Zbadano pięć funkcji, cztery biblioteczne i jedną własną.
Starano się wybrać funkcję które są koniecznym elementem 
budulcowym w aplikacjach przetwarzających sygnały audio.
Każdy test znajduje się w jednym pliku w którym muszą
znajdywać się funkcje: \lstinline{prepare_input()} -- 
przygotowuje dane wejściowe dla testowanej funkcji, jako
argument przyjmuje ilość elementów wektora danych,
\lstinline{test_function()} -- testowana funkcja, przyjmuje
dane przygotowane przez funkcję \lstinline{prepare_input()},
przetwarza je i zwraca wynik. W kolejnych punktach zostaną
opisane pokrótce te testy wraz z przykładowym kodem
w jednym z testowanych języków. Jeśli nie jest napisane
inaczej, to w testach w pythonie korzystano z funkcji
z biblioteki \emph{NumPy}.

\subsection{Sinus}
\label{sec:sin}

Jako pierwszą zbadano, jedną z najbardziej podstawowych
funkcji matematycznych, jaką jest sinus. Jest to najprostszy
test, funkcja przygotowująca dane
tworzy tablicę punktów rozmieszczonych w równych odległościach
pomiędzy $0$, a $2\pi$, natomiast funkcja testowana wywołuje
funkcję \lstinline{sin()} na tych danych (Tab. \ref{tab:sintest}).
W teście dla pakietu \emph{Anaconda} wykorzystano bibliotekę
\emph{numexpr} (Patrz punkt \ref{sec:anaconda}).

\begin{table}[h]%
  \caption{Kod testu \emph{sin} (Python)}%
  \lstinputlisting[language=Python, firstline=3]{../tests/python/tests/sin/test.py}%
  \label{tab:sintest}%
\end{table}%

\subsection{FFT}
\label{sec:fft}

FFT (Fast Fourier Transform) jest niezwykle istotnym algorytmem w analizie
sygnałów audio, pozwala wykonać dyskretną transformatę
Fouriera w znacznie krótszym czasie niż algorytm naiwny.

\subsubsection{Funkcja biblioteczna}
\label{sec:fftbib}

Danymi wejściowymi jest sygnał audio, będący sumą dwóch
sinusów o częstotliwościach \SI{50}{\hertz} i \SI{120}{\hertz}
oraz szumu białego, o częstotliwości próbkowania \SI{1}{\kilo\hertz}.
Funkcja testowana wywołuje na tym sygnale funkcję \lstinline{fft()}
(Tab. \ref{tab:ffttest}). Kod testu oparty jest na dokumentacji
funkcji \lstinline{fft()} dla pakietu MATLAB[odnośnik]. W pakiecie \emph{Anaconda} jest
dostępnych kilka implementacji FFT, wykorzystano tę której wyniki
były najlepsze -- \lstinline{fftpack.fft()} z biblioteki \emph{SciPy}. 
Natomiast w Julii zastosowano dyrektywę
\lstinline{FFTW.set_num_threads(Sys.CPU_CORES)}, która pozwala
wykorzystać wszystkie dostępne wątki procesora do obliczeń,
znacznie przyspieszając obliczenia[odnośnik do doumentacji].

\begin{table}[h]%
  \caption{Kod testu \emph{fft} (Python)}%
  \lstinputlisting[language=Python, firstline=2]{../tests/python/tests/fft/test.py}%
  \label{tab:ffttest}%
\end{table}%

\subsubsection{Algorytm własny}
\label{sec:fftwla}

Ważnym elementem użytkowania pakietów obliczeniowych jest
tworzenie własnych procedur, gdyż nie wszystkie
potrzebne funkcje są zawsze w bibliotekach. Aby przetestować
jak dobrze dany pakiet jest w stanie zoptymalizować
ręcznie stworzoną procedurę, napisano w każdym z języków
dokładnie tę samą funkcję. Funkcją tą jest procedura FFT
\lstinline{four1()} opisana w
\emph{Numerical Recipes in C}[Odnośnik]
(oparta na procedurze opisanej przez N. M. Brennera), przepisana
z języka C do jeżyków testowanych pakietów oraz zaadaptowana do
korzystania z natywnych typów liczb zespolonych, które
występują we wszystkich badanych pakietach. Dane wejściowe
są identyczne jak w punkcie \ref{sec:fftbib}, lecz, jako że
ta procedura operuje tylko na tablicach, których rozmiar
jest potęgą liczby dwa, są one wydłużane przez dodanie
odpowiedniej ilości zer.

Procedura \lstinline{four1()} (Zał. \ref{chap:zalfour1}) implementuje algorytm
Cooleya-Tukeya i składa się z dwóch sekcji. Pierwsza sekcja
to pętla która zamienia miejscami elementy wektora
wejściowego w taki sposób, że gdyby ponumerować wszystkie
elementy wektora wejściowego od zera rosnąco w systemie dwójkowym, to po
zamianach ta numeracja była by malejąca, w tym celu zamieniane
są elementy wektora wejściowego które są swoim odbiciem lustrzanym
(np. 001 i 100). Druga sekcja zawiera pętle, która
wykonuje się $log_2N$ razy (gdzie $N$ to długość wektora
wejściowego). Dwie wewnętrzne pętle
wymnażają odpowiednio elementy poprzednich transformat
obliczając nową, o dwa razy większym rozmiarze. 
Każdy z elementów wektora jest jednopunktową
transformatą Fouriera, które następnie łączy się w transformaty
o długościach $2, 4, 8, \dots, N$, stosując lemat
Danielsona-Lanczosa (\ref{eq:lanczos}). 
\begin{equation}%
  F_k=F^e_k+e^{-2k\pi i/N}F^o_k
  \label{eq:lanczos}
\end{equation}%
gdzie%
\begin{eqwhere}[2cm]%
\item[$F_k$] $k$-ty punkt dyskretnej transformaty Fouriera
\item[$F_k^e$] $k$-ty punkt elementów transformaty o parzystym indeksie
\item[$F_k^o$] $k$-ty punkt elementów transformaty o nieparzystym indeksie
\item[$N$] ilość punktów dyskretnej transformaty Fouriera
\end{eqwhere}%
  
\subsection{Splot}
\label{sec:splot}
  
Splot jest istotną operacją dla przetwarzania sygnałów,
gdyż pozwala on stosować filtry (FIR, IIR), oraz symulować
wpływ środowisk akustycznych na sygnał poprzez splecenie
ich odpowiedzi impulsowych z sygnałem. Funkcja testowana
wywołuje splot na dwóch tablicach z wartościami losowymi
(Tab. \ref{tab:convtest}).

\begin{table}[h]%
  \caption{Kod testu \emph{conv} (MATLAB/GNU Octave)}%
  \lstinputlisting[language=MATLAB, firstline=6]{../tests/matlab/tests/conv/test.m}%
  \label{tab:convtest}%
\end{table}%

\subsection{Wczytywanie pliku audio}
\label{sec:wavread}

Aby móc sygnał poddać obróbce należy go najpierw wczytać
do pamięci pakietu. W przypadku dużych plików, wczytywanie
może być stosunkowo długim procesem. Aby to przetestować
funkcja przygotowująca tworzy plik w formacie WAV, z
częstotliwością próbkowania \SI{48}{\kilo\hertz} i
rozdzielczością bitową \SI{16}{\bit}, o odpowiedniej liczbie
próbek, natomiast funkcja testowana wczytuje go do pamięci
(Tab. \ref{tab:wavreadtest}).
\begin{table}[h]%
  \caption{Kod testu \emph{wavread} (Scilab)}%
  \lstinputlisting[language=Scilab, firstline=3]{../tests/scilab/tests/wavread/test.sci}%
  \label{tab:wavreadtest}%
\end{table}%

\chapter{Wyniki testów}
\label{chap:wyniki}

Do przetwarzania danych wynikowych wykorzystano biblioteki
\emph{reshape2} i \emph{dplyr}[odnośniki?], natomiast
wykresy stworzono za pomocą biblioteki \emph{ggplot2}.
Na wykresie oznaczono medianę czasu wykonania procedury
testowanej oraz przedział od wartości minimalnej do
maksymalnej dla \SI{95}{\percent} najmniejszych wyników.
Pominięto \SI{5}{\percent} najwyższych wyników z powodu
ich nieporównywalnie wysokiej wartości, powodującej 
znaczne zmniejszenie czytelności wykresów. Ponieważ tego typu
wyniki, których wartość była ponad dwa razy wyższa niż
wartość średnia występowały dla wszystkich pakietów, uznano
że są one spowodowane tymczasowym niedoborem lub
spowolnieniem zasobów przez nie wykorzystywanych albo
uruchomieniem \emph{GC} (\emph{Garbage Collector} --
jest to pewna część języka programowania, która
zajmuje się oczyszczaniem pamięci ze zmiennych,
do których nie ma już odnośników w programie).

Każdy test wywoływał funkcję testowaną
\num{\Sexpr{length(results.intel$fft$octave[1,])}}
razy co
pozwoliło zminimalizować wpływ losowych czynników
niepożądanych na wyniki. Kolejne punkty zawierają
wykresy z wynikami oraz ich interpretację. W punkcie
\ref{sec:sum} znajduje się podsumowanie wyników.

\section{Sinus}
\label{sec:wynsin}

Jak można zauważyć (Rys. \ref{fig:sin.intel} i \ref{fig:sin.amd}),
zastosowanie biblioteki \emph{NumExpr} w Pythonie,
pozwala obliczyć sinus dla dużych w wektorów wejściowych,
znacznie szybciej w Anacondzie, w czasie średnio o
\SI{\Sexpr{percentFaster(results.intel$sin, "matlab", "python")}}{\percent} %$
krótszym niż MATLAB.
Różnica jest mniejsza w przypadku komputera stacjonarnego,
prawdopodobnie z powodu mniejszej ilości wątków procesora
(\SI{\Sexpr{percentFaster(results.amd$sin, "matlab", "python")}}{\percent}). %$
MATLAB jest drugi pod względem czasu wykonywania procedury
wykonując funkcję \lstinline{sin()} w średnio o
\SI{\Sexpr{percentFaster(results.intel$sin, "julia", "matlab")}}{\percent} %$
krótszym czasie niż Julia.
(\SI{\Sexpr{percentFaster(results.amd$sin, "julia", "matlab")}}{\percent} %$
dla AMD). Różnice pomiędzy Julią a GNU Octave i Scilabem są niewielkie
(\SI{\Sexpr{percentFaster(results.intel$sin, "octave", "julia")}}{\percent} %$
dla Intela i 
\SI{\Sexpr{percentFaster(results.amd$sin, "octave", "julia")}}{\percent} %$
dla AMD)
W Julii funkcje takie jak \lstinline{linspace()}, lub
konstrukcje \lstinline{start:step:end} nie tworzą całych
tablic, ale specjalne obiekty których elementy są wyliczane
dopiero, gdy jest wymagany do nich dostęp[odnośnik do dokumentacji],
pozwala to przyspieszyć operacje, które nie wykorzystują
wszystkich wartości z wektora, natomiast w przypadku tego testu
działa to na niekorzyść, gdyż z każdym wywołaniem funkcji
\lstinline{sin.()} muszą być wyliczone wszystkie elementy
wektora wejściowego. Używając funkcji \lstinline{collect()}
można zamienić te obiekty na wektory. Z przeprowadzonych
krótkich testów wynikło jednak, że wpływ tego jest stosunkowo
niewielki, na poziomie \SI{10}{\percent}.

<<sin.intel, fig.cap="Wyniki testu funkcji \\lstinline{sin()} (Laptop/Intel)">>=

preparePlot(results.intel$sin)

@ 

<<sin.amd, fig.cap="Wyniki testu funkcji \\lstinline{sin()} (PC/AMD)">>=

preparePlot(results.amd$sin)

@ 

\section{FFT}
\label{sec:wynfft}

\subsection{Funkcja biblioteczna}
\label{sec:wynfftbib}

Wyniki testu funkcji \lstinline{fft()} są o tyle ciekawe,
że wszystkie pakiety, poza Anacondą, wykorzystują bibliotekę
\emph{FFTW}[odnośnik] (skrót pochodzi od
\emph{Fastest Fourier Transform in the West}) -- jest to jedna
z naszybszych bibliotek liczących transformatę Fouriera, napisana
głownie w C. Nie jest ona używana przez \emph{SciPy} z powodu
niekompatybilnych licencji, lecz istnieje możliwość wykorzystania
\emph{FFTW} w Pythonie wykorzystując bibliotekę \emph{PyFFTW}. Nie
zawiera się ona jednak w podstawowej dystrybucji Anacondy, toteż
jej nie wykorzystano do testów, choć mogłaby ona zmniejszyć
czas obliczeń. Każdy z pakietów wykorzystuje własną wersję \emph{FFTW}
z pewnymi modyfikacjami, które potrafią poprawić wydajność,
ponadto \emph{FFTW} pozwala na wykorzystanie tzw. \emph{planowania FFT}
-- jest to proces w którym biblioteka wstępnie oblicza macierz
transformacji dla danego rozmiaru FFT, co pozwala znacznie
przyspieszyć obliczanie kolejnych FFT o tym samym rozmiarze
po prostu mnożąc sygnał przez tę macierz. To, oraz fakt, że
\emph{FFTW} pozwala modyfikować wiele parametrów algorytmu
obliczania FFT, powoduje że różnice, choć nie bardzo duże,
istnieją (Rys. \ref{fig:fft.intel} i \ref{fig:fft.amd}.

Najkrócej oblicza GNU Octave w czasie średnio o
\SI{\Sexpr{percentFaster(results.intel$fft, "matlab", "octave")}}{\percent} %$
krótszym niż MATLAB, o
\SI{\Sexpr{percentFaster(results.intel$fft, "julia", "octave")}}{\percent} %$
krótszym niż Julia, o
\SI{\Sexpr{percentFaster(results.intel$fft, "python", "octave")}}{\percent} %$
krótszym niż Python i o
\SI{\Sexpr{percentFaster(results.intel$fft, "scilab", "octave")}}{\percent} %$
krótszym niż Scilab (odpowiednio
\SI{\Sexpr{percentFaster(results.amd$fft, "matlab", "octave")}}{\percent}, %$
\SI{\Sexpr{percentFaster(results.amd$fft, "julia", "octave")}}{\percent}, %$
\SI{\Sexpr{percentFaster(results.amd$fft, "python", "octave")}}{\percent} i %$
\SI{\Sexpr{percentFaster(results.amd$fft, "scilab", "octave")}}{\percent} %$
dla AMD).

<<fft.intel, fig.cap="Wyniki testu funkcji \\lstinline{fft()} (Laptop/Intel)">>=

preparePlot(results.intel$fft)

@ 

<<fft.amd, fig.cap="Wyniki testu funkcji \\lstinline{fft()} (PC/AMD)">>=

preparePlot(results.amd$fft)

@ 

\subsection{Algorytm własny}
\label{sec:wynfftwla}

Jak widać na wykresach (Rys. \ref{fig:four1.intel} i \ref{fig:four1.amd}),
funkcja \lstinline{four()} nie chociaż ani trochę tak
wydajna jak algorytmy biblioteczne, lecz nie to było jej
celem. Dzięki porównaniu szybkości tej funkcji można zobaczyć jak
dobrze sobie radzi każdy z pakietów z optymalizacją
kodu napisanego przez użytkownika. Algorytm funkcji testowanej
(Opis w punkcie \ref{sec:fftwla})
zawiera dużo pętli i nie stosuje \emph{wektoryzacji} kodu --
czyli używania funkcji operujących na wektorach zamiast
korzystania z pętli. Praktyka \emph{wektoryzacji} jest
zalecana w badanych językach, za wyjątkiem Julii[odnośnik?],
lecz wymaga ona większej wprawy, toteż należy brać pod uwagę
że testowany kod nie jest optymalny pod względem wydajności,
natomiast jest on dobrym przykładem kodu napisanego na szybko
w celu przetestowania jakiejś idei.
Jako że stosowany algorytm jest bardzo prosty i nie
stosuje żadnych zaawansowanych technik optymalizacji
FFT różnice pomiędzy pakietami są niemalże identyczne
dla każdego z rozmiarów wektora wejściowego. Z tego
samego powodu nie ma też dużych różnic pomiędzy
wynikami z laptopa i komputera stacjonarnego.

Dobra optymalizacja pętli w Julii, pozwala uzyskać jej
najlepszy czas w tym teście, obliczając FFT, w czasie o
\SI{\Sexpr{percentFaster(results.amd$four1, "matlab", "julia")}}{\percent} %$
krótszym niż MATLAB, o
\SI{\Sexpr{percentFaster(results.intel$four1, "python", "julia")}}{\percent} %$
krótszym niż Python, o
\SI{\Sexpr{percentFaster(results.intel$four1, "scilab", "julia")}}{\percent} %$
krótszym niż Scilab i o
\SI{\Sexpr{percentFaster(results.intel$four1, "octave", "julia")}}{\percent} %$
krótszym niż GNU Octave (odpowiednio
\SI{\Sexpr{percentFaster(results.amd$four1, "matlab", "julia")}}{\percent}, %$
\SI{\Sexpr{percentFaster(results.amd$four1, "python", "julia")}}{\percent}, %$
\SI{\Sexpr{percentFaster(results.amd$four1, "scilab", "julia")}}{\percent} i %$
\SI{\Sexpr{percentFaster(results.amd$four1, "octave", "julia")}}{\percent} %$
dla AMD).
To są niesamowicie duże różnice i ukazują potencjał
jaki ma Julia jako narzędzie do szybkiego prototypowania.

<<four1.intel, fig.cap="Wyniki testu funkcji \\lstinline{four1()} (Laptop/Intel)">>=

preparePlot(results.intel$four1)

@ 

<<four1.amd, fig.cap="Wyniki testu funkcji \\lstinline{four1()} (PC/AMD)">>=

preparePlot(results.amd$four1)

@ 

\section{Splot}
\label{sec:wynsplot}

Wyniki testów funkcji \lstinline{conv()}, są niezwykle
ineteresujące (Rys. \ref{fig:conv.intel} i \ref{fig:conv.amd}),
gdyż występują tu olbrzymie różnice pomiędzy pakietami.
Szczególnie wyróżnia się Julia wykonując splot w czasie o
\SI{\Sexpr{percentFaster(results.intel$conv, "matlab", "julia")}}{\percent} %$
krótszym niż MATLAB (%
\SI{\Sexpr{percentFaster(results.amd$conv, "matlab", "julia")}}{\percent} %$
dla AMD). Ta duża różnica jest spowodowana wykorzystaniem
algorytmu splotu wykorzystującego FFT
(patrz następny akapit).
MATLAB za to splata w czasie o
\SI{\Sexpr{percentFaster(results.intel$conv, "python", "matlab")}}{\percent} %$
krótszym niż Python na laptopie, natomiast w czasie tylko o
\SI{\Sexpr{percentFaster(results.amd$conv, "python", "matlab")}}{\percent} %$
krótszym na komputerze stacjonarnym, gdyz tam
kod w Pythonie wykonuje się szybciej. Może to wskazywać
na nie wykorzystanie przez algorytm wielowątkowości
procesora, co spowodowało lepszy wynik na wyżej taktowanym
procesorze AMD.
Od Scilaba MATLAB wykonuje splot o
\SI{\Sexpr{percentFaster(results.intel$conv, "scilab", "matlab")}}{\percent} %$
krócej, natomiast od GNU Octave o
\SI{\Sexpr{percentFaster(results.intel$conv, "octave", "matlab")}}{\percent} %$
krócej (%
\SI{\Sexpr{percentFaster(results.amd$conv, "scilab", "matlab")}}{\percent} i %$
\SI{\Sexpr{percentFaster(results.amd$conv, "octave", "matlab")}}{\percent} %$
dla AMD).

<<conv.intel, fig.cap="Wyniki testu funkcji \\lstinline{conv()} (Laptop/Intel)">>=

preparePlot(results.intel$conv)

@ 

\begin{table}[!hbt]
\caption{Implementacja splotu FFT w MATLABie/GNU Octave}
\begin{lstlisting}[language=MATLAB]
function Y = fftconv(X1, X2)
    pad1 = zeros(1, length(X2) - 1);
    pad2 = zeros(1, length(X1) - 1);
    Y = abs(ifft(fft([X1 pad1]).*fft([X2 pad2])));
end
\end{lstlisting}
\label{tab:fftconv}
\end{table}

Algorytm stosowany przez badane pakiety, za wyjątkiem
Julii, opiera się najprawdopodobniej na definicji
splotu, nie jest to jednak
najefektywniejsze rozwiązanie, gdyż jest możliwe
obliczenie splotu za pomocą FFT. Należy w tym celu
wydłużyć oba wektory wejściowe o odpowiednią ilość
zer, tak by oba miały długość równą sumie długości
wektorów wejściowych mniej jeden. Następnym krokiem
jest zamiana obu wektorów na dziedzinę częstotliwości,
poprzez FFT, wymnożenie transformat z obu sygnałów i
wykonanie odwrotnego FFT na sygnale wynikowym (Tab.
\ref{tab:fftconv} przedstawia przykładową implementację).
Ten algorytm korzysta z faktu, że splot w dziedzinie
czasu równy jest mnożeniu w dziedzinie częstotliwości.
Czas wykonania takiej procedury będzie zbliżony do
czasu potrzebnego na wykonanie trzech operacji FFT,
krótkie testy pokazały ponad stukrotnie krótszy
czas wykonania tej procedury w GNU Octave od procedury
bibliotecznej dla dużych wektorów wejściowych.
Ta procedura jest zaimplementowana w bibliotece
\emph{SciPy} jako \lstinline{signal.fftconvolve()}.

<<conv.amd, fig.cap="Wyniki testu funkcji \\lstinline{conv()} (PC/AMD)">>=

preparePlot(results.amd$conv)

@ 

\section{Wczytywanie pliku audio}
\label{sec:wynwavread}

Jak obrazują wykresy (Rys. \ref{fig:wavread.intel} i \ref{fig:wavread.amd})
biblioteka \emph{WAV.jl} w Julii jest wyjątkowo
nieefektywna we wczytywaniu plików dłuższych niż około \SI{0.2}{\second},
w istocie GNU Octave wczytuje pliki w czasie o
\SI{\Sexpr{percentFaster(results.intel$wavread, "julia", "octave")}}{\percent} %$
krótszym niż Julia (%
\SI{\Sexpr{percentFaster(results.amd$wavread, "julia", "octave")}}{\percent} %$
na HDD). Tak długie czasy wczytywania
plików audio mogą nakłonić użytkowników do rozglądania
się za alternatywnymi rozwiązaniami. Scilab również
odbiega od reszty pakietów, GNU Octave wczytuje w czasie o
\SI{\Sexpr{percentFaster(results.intel$wavread, "scilab", "octave")}}{\percent} %$
krótszym od niego (%
\SI{\Sexpr{percentFaster(results.amd$wavread, "scilab", "octave")}}{\percent} %$
dla HDD).
Od MATLABa ani od Pythona, GNU Octave nie jest dużo szybsze,
bo wczytuje tylko w odpowiednio o
\SI{\Sexpr{percentFaster(results.intel$wavread, "matlab", "octave")}}{\percent} %$
i o
\SI{\Sexpr{percentFaster(results.intel$wavread, "python", "octave")}}{\percent} %$
krótszym niż te pakiety (%
\SI{\Sexpr{percentFaster(results.amd$wavread, "matlab", "octave")}}{\percent} %$
i
\SI{\Sexpr{percentFaster(results.amd$wavread, "python", "octave")}}{\percent} %$
na HDD). Interesujący jest brak znaczących różnic pomiędzy
wynikami z laptopa z wykorzystaniem znacznie szybszego
dysku typu SSD, a komputerem stacjonarnym z dyskiem HDD.
Wskazuje to na pomijalny wpływ prędkości dysku na
wczytywanie plików audio w tych pakietach, a istniejące
różnice pomiędzy wynikami z laptopa i PC, spowodowane
są prawdopodobnie wolniejszym procesorem i pamięcią RAM.


Należy wspomnieć, że \emph{WAV.jl} nie jest jedyną
biblioteką do wczytywania plików \emph{wav}, choć jest
to biblioteka najpopularniejsza oraz jest ona wykorzystywana
przez bibliotekę \emph{FileIO} oferującą zunifikowany
interfejs do wczytywania wszelkiego rodzaju plików.
Jedną z alternatyw jest biblioteka \emph{LibSndFile.jl},
która korzysta z biblioteki \emph{libsndfile} napisanej
w C[odnośnik]. Krótkie testy wykazały dziewięciokrotnie
krótszy czas wczytywania przy wykorzystaniu tej biblioteki.


<<wavread.intel, fig.cap="Wyniki testu funkcji \\lstinline{wavread()} (Laptop/SSD)">>=

preparePlot(results.intel$wavread)

@ 

<<wavread.amd, fig.cap="Wyniki testu funkcji \\lstinline{wavread()} (PC/HDD)">>=

preparePlot(results.amd$wavread)

@ 

\section{Sumaryczne zestawienie wyników}
\label{sec:sum}

Patrząc na wykresy (Rys. \ref{fig:summary.intel} i \ref{fig:summary.amd})
można zaobserwować, że nie ma jednego pakietu, którego
zastosowanie w każdej sytuacji pozwoli uzyskać wyniki w
najkrótszym możliwym czasie. W każdym z wykonanych testów inne
pakiety wykonały testowaną funkcję najszybciej, a inne najwolniej.

Jednym wyjątkiem jest Scilab który wykonał każdy z testów
w najdłuższym (w dwóch przypadkach) lub drugim od końca (w
trzech przypadkach) czasie. To, oraz problemy z instalacją
tego pakietu (patrz punkt \ref{sec:srodowisko}), to duże
powody by przemyśleć wykorzystanie alternatywnego rozwiązania.

MATLAB jest na bardzo silnej pozycji będąc drugim najszybszym
pakietem w każdym z testów. Choć w żadnym przypadku nie jest
najszybszy, w każdym jest szybki. Z pewnością jest to narzędzie,
którego zastosowanie w każdej sytuacji będzie pozwalało szybko
wykonać potrzebne obliczenia jest więc dobrym wyborem na każdą
okazję, lecz do każdego z zadań znajdzie się szybsza alternatywa,
na przykład jeżeli celem jest napisanie algorytmu który będzie
w dużym stopniu wykorzystywał pętle, lepiej skorzystać z Julii.

Anaconda jest doskonałą alternatywą dla MATLABa, gdyż, pod względem
prędkości ustępuje mu nieznacznie, albo w ogóle (w teście funkcji
\lstinline{sin()}). Zastosowanie rozwiązań opisanych w 
punktach \ref{sec:wynfft} i \ref{sec:wynsplot} może pozwolić
dodatkowo zwiększyć szybkość wykonywania funkcji \lstinline{fft()}
i \lstinline{conv()} pomniejszając różnice jeszcze bardziej.

Również dobrą alternatywą jest Julia, która w dwóch testach
wykonała funkcje trochę szybciej
(\lstinline{conv()} i \lstinline{four1()}), a w dwóch
trochę wolniej (\lstinline{sin()} i \lstinline{fft()}), co
stawiałoby ją na dobrej pozycji gdyby nie niesamowicie wolne
wykonanie testu wczytywania plików \emph{wav}. Co może nie być
problemem jeżeli się z tej funkcjonalności nie korzysta, ponadto
w punkcie \ref{sec:wynwavread} opisano rozwiązanie które
częściowo rozwiązuje ten problem.

GNU Octave jest o tyle ciekawym przypadkiem, że w testach
funkcji \lstinline{fft()} i \lstinline{wavread()} wypada
minimalnie lepiej niż MATLAB, lecz w testach \lstinline{conv()}
i \lstinline{four1()} wykazuje niezwykle długi czas
obliczeń w porównaniu z pozostałymi pakietami.
W teście \lstinline{sin()} jest na ostatnim miejscu
ex aequo z Scilabem. Jedno z rozwiązań na wolne wykonywanie
się splotu zostało opisane w punkcie \ref{sec:wynsplot},
lecz tak zły wynik w teście \lstinline{four1()} jest
poważną przeszkodą do wykorzystania tego pakietu jako
narzędzie do szybkiego prototypowania aplikacji
przetwarzających sygnały audio.

Nie zauważono znacznych różnic pomiędzy wynikami z
laptopa i PC, poza oczywistymi dłuższymi czasami
na PC spowodowanymi wolniejszy procesorem. Jednym
wyjątkiem jest test funkcji \lstinline{conv()}
w którym test w Pythonie wykonał się (proporcjonalnie
do MATLABA) szybciej na komputerze stacjonarnym niż na
laptopie. Mimo tego można uznać, że wyniki są niewiele
zależne od rodzaju procesora, w istocie ich duże podobieństwo
sugeruje dużą powtarzalność.

<<summary.intel, fig.cap="Średnia ważona wyników testów (Laptop)">>=
summaryPlot(results.intel)

@ 

<<summary.amd, fig.cap="Średnia ważona wyników testów (PC)">>=
summaryPlot(results.amd)

@ 
\chapter{Podsumowanie}
\label{chap:podsumowanie}

\section{Sumaryczna analiza wyników}
\label{sec:sumanaliza}

\section{Dalsze kierunki badań}
\label{sec:kier}



% Bibliografia
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliografia}
\printbibliography


% Załączniki
\begin{appendices}
  \makeatletter%
  \addtocontents{toc}{\let\protect\l@chapter\protect\l@section}
  \makeatother%

  \chapter{Kod testu \emph{four1} (Julia)}
  \label{chap:zalfour1}
  {\singlespacing\lstinputlisting[language=Julia, firstline=13]{../tests/julia/tests/four1/test.jl}}
\end{appendices}

\end{document}
