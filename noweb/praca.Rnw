\PassOptionsToPackage{binary-units=true}{siunitx}

\documentclass[pl,12pt]{aghdpl}
% \documentclass[en,11pt]{aghdpl}  % praca w języku angielskim

% Lista wszystkich języków stanowiących języki pozycji bibliograficznych użytych w pracy.
% (Zgodnie z zasadami tworzenia bibliografii każda pozycja powinna zostać utworzona zgodnie z zasadami języka, w którym dana publikacja została napisana.)
\usepackage[english,polish]{babel}

% Użyj polskiego łamania wyrazów (zamiast domyślnego angielskiego).
\usepackage{polski}

\usepackage[utf8]{inputenc}

\usepackage[T1]{fontenc}

% dodatkowe pakiety

\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{float}% do umieszczenia floatów [h]
\usepackage{enumitem}
\setlist{nosep} % or \setlist{noitemsep} to leave space around whole list
\usepackage[bookmarks]{hyperref}

% floaty w sekcji w które są stworzone

\usepackage{placeins}

\let\Oldsection\section
\renewcommand{\section}{\FloatBarrier\Oldsection}

\let\Oldsubsection\subsection
\renewcommand{\subsection}{\FloatBarrier\Oldsubsection}

\let\Oldsubsubsection\subsubsection
\renewcommand{\subsubsection}{\FloatBarrier\Oldsubsubsection}

% specjalistyczne pakiety

\usepackage{dirtree}% Drzewo folderów
\usepackage[full]{textcomp}% Symbole trademark, registered...

% --- < bibliografia > --


\usepackage[
style=numeric,
sorting=none,
% 
% Zastosuj styl wpisu bibliograficznego właściwy językowi publikacji.
language=autobib,
autolang=other,
% Zapisuj datę dostępu do strony WWW w formacie RRRR-MM-DD.
urldate=iso8601,
% Nie dodawaj numerów stron, na których występuje cytowanie.
backref=false,
% Podawaj ISBN.
isbn=true,
% Nie podawaj URL-i, o ile nie jest to konieczne.
url=false,
% 
% Ustawienia związane z polskimi normami dla bibliografii.
maxbibnames=3,
% Jeżeli używamy Bibera:
backend=biber
]{biblatex}

\usepackage{csquotes}
% Ponieważ `csquotes` nie posiada polskiego stylu, można skorzystać z mocno zbliżonego stylu chorwackiego.
\DeclareQuoteAlias{croatian}{polish}

\addbibresource{bibliografia.bib}

% Nie wyświetlaj wybranych pól.
% \AtEveryBibitem{\clearfield{note}}


% ------------------------
% --- < listingi > ---

% Użyj czcionki kroju Times.
\usepackage{newtxtext}
\usepackage{newtxmath}

\usepackage{listings}
\lstloadlanguages{MATLAB}

\lstset{%
  literate={ą}{{\k{a}}}1
  {ć}{{\'c}}1
  {ę}{{\k{e}}}1
  {ó}{{\'o}}1
  {ń}{{\'n}}1
  {ł}{{\l{}}}1
  {ś}{{\'s}}1
  {ź}{{\'z}}1
  {ż}{{\.z}}1
  {Ą}{{\k{A}}}1
  {Ć}{{\'C}}1
  {Ę}{{\k{E}}}1
  {Ó}{{\'O}}1
  {Ń}{{\'N}}1
  {Ł}{{\L{}}}1
  {Ś}{{\'S}}1
  {Ź}{{\'Z}}1
  {Ż}{{\.Z}}1
}

\usepackage{color}

% --- < kolorowanie kodu > ---

% From overleaf.com
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},     % choose the background color
  basicstyle=\ttfamily\footnotesize, % size of fonts used for the code
  breaklines, breakatwhitespace,     % automatic line breaking only at whitespace
  commentstyle=\color{mygreen},      % comment style
  numbers=left,
  showstringspaces=false,
  numberstyle=\tiny,
  frame=l,
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  keywordstyle=\color{blue},         % keyword style
  stringstyle=\color{mymauve}        % string literal style
}

%%
%% Julia definition (c) 2014 Jubobs
%%
\lstdefinelanguage{Julia}%
  {morekeywords={abstract,break,case,catch,const,continue,do,else,elseif,%
      end,export,false,for,function,immutable,import,importall,if,in,%
      macro,module,otherwise,quote,return,switch,true,try,type,typealias,%
      using,while,begin},%
   sensitive=true,%
   alsoother={$},%$
   morecomment=[l]\#,%
   morecomment=[n]{\#=}{=\#},%
   morestring=[s]{"}{"},%
   morestring=[m]{'}{'},%
}[keywords,comments,strings]%

% ------------------------

\AtBeginDocument{
  \renewcommand{\tablename}{Tab.}
  \renewcommand{\figurename}{Rys.}
}

% ------------------------
% --- < tabele > ---

\usepackage{array}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage[flushleft]{threeparttable}

% defines the X column to use m (\parbox[c]) instead of p (`parbox[t]`)
\newcolumntype{C}[1]{>{\hsize=#1\hsize\centering\arraybackslash}X}

% --------------------------Ustawienia Knitr---------------------------------

<<Opcje globalne, include=FALSE>>=
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
knitr::opts_knit$set(concordance = TRUE);

Sys.setlocale(category = 'LC_ALL','en_US.UTF-8')
Sys.setenv(LANG="EN")
Sys.setlocale("LC_TIME","C")
@ 

%--------------------------Funkcje------------------------------------------

<<Funkcje>>=
library(h5)
library(ggplot2)
library(reshape2)
library(dplyr)

packages <- c("julia","octave","matlab","python","scilab")
tests <- c("sin", "conv", "fft", "four1", "wavread")

rowMax <- function(x, shaveoffpercent=5) {
    apply(x, 1, function(e) {
        max(shaveoff(e, shaveoffpercent), na.rm=TRUE)
    })
}

rowMin <- function(x) {
    apply(x, 1, function(e) {
        min(e, na.rm=TRUE)
    })
}

rowMedian <- function(x) {
    apply(x, 1, function(e) {
        median(e, na.rm=TRUE)
    })
}

rowCountNA  <- function(x) {
    apply(x, 1, function(e) {
        sum(is.na(e))/length(e)
    })
}

shaveoff  <- function(vec, percent) {
    vec[-tail(order(vec), floor(percent*length(vec)/100))]
}

getResults <- function(h5df_file) {
    results <- list()
    for (test_name in tests) {
        results[[test_name]] <- list()
        max_input_size <- length(list.datasets(h5df_file[test_name]["octave"]))
        for (package in packages) {
            number_of_tests  <- length(h5df_file[test_name][package]["1"][])
            results[[test_name]][[package]] <- matrix(NA,max_input_size,number_of_tests)
            for (input_size in 1:max_input_size) {
                res <- as.vector(h5df_file[test_name][package][toString(input_size)][])
                results[[test_name]][[package]][input_size,1:length(res)] <- res
            }
        }
    }
    results
}

preparePlot <- function(res) {
    means <- lapply(res, rowMedian)
    mins <- lapply(res, rowMin)
    maxs <- lapply(res, rowMax)

    means.molten <- as.data.frame(melt(means) %>% group_by(L1) %>% mutate(id = row_number()))
    mins.molten <- as.data.frame(melt(mins) %>% group_by(L1) %>% mutate(id = row_number()))
    maxs.molten <- as.data.frame(melt(maxs) %>% group_by(L1) %>% mutate(id = row_number()))

    means.molten["VectorSize"] <- 10^means.molten["id"]

    plot <- ggplot(means.molten, aes(x=VectorSize, y=value, colour=L1)) 
    plot <- plot + geom_errorbar(aes(ymin=mins.molten["value"], ymax=maxs.molten["value"]), width=.1)
    plot <- plot + scale_y_log10() + scale_x_log10() + geom_point() + geom_line()
    plot <- plot + xlab("Ilo\\'s\\'c element\\'ow wektora wej\\'sciowego")
    plot <- plot + ylab("Czas wykonywania procedury [$\\si{\\second}$]")
    plot <- plot + labs(colour="Pakiet obliczeniowy")
    plot <- plot + theme_bw() + theme(legend.position=c(0.01,0.99), legend.justification=c(0.01,0.99))
    plot
}

summaryMelt <- function(res, func) {
    as.data.frame(melt(lapply(res, function(package) {
        melt(lapply(package, function(x) {
            fff <- func(x)
            tens <- 10^(1:length(fff))
            sum(fff*tens)/sum(tens)
        }))
    })) %>% group_by(L1) %>% mutate(id = packages[row_number()]))
}

summaryPlot <- function(res) {
    sumres <- summaryMelt(res, rowMedian)
    summax <- summaryMelt(res, rowMax)
    summin <- summaryMelt(res, rowMin)

    plot <- ggplot(sumres, aes(x=L1, y=value, colour=id)) 
    plot <- plot + geom_point() + theme_bw() + scale_y_sqrt()
    plot <- plot + geom_errorbar(aes(ymin=summin["value"], ymax=summax["value"]), width=.1)
    plot <- plot + ylab("Czas wykonywania procedury [$\\si{\\second}$]")
    plot <- plot + xlab("Testowana funkcja")
    plot <- plot + labs(colour="Pakiet obliczeniowy")
    plot
}

percentFaster <- function(res, name1, name2) {
    means <- rowMeans(res[[name1]])/rowMeans(res[[name2]])
    tenseq <- 10^(1:length(means))
    round(100 - 100*sum(tenseq)/sum(means*tenseq))
}
@ 
%----------------------------Zmienne----------------------------------------

<<Inicjalizacja zmiennych>>=
author <- "Szymon Mikulicz"
shortAuthor <- paste(substr(author,1,1),'. ',unlist(strsplit(author,'[ ]'))[2],sep='')

results.file <- h5file("../tests/results.amd.h5", "r")
results.amd <- getResults(results.file)
h5close(results.file)

results.file <- h5file("../tests/results.intel.h5", "r")
results.intel <- getResults(results.file)
h5close(results.file)
@ 

%-------------------------Ustawienia TikzDevice---------------------------

<<tikzSettings>>=
options(width=71)
options(digits=7)

require("knitr")

opts_chunk$set(
               keep.source=TRUE,
               out.width='5in',
               fig.width=5,
               fig.height=5/sqrt(2),
               fig.lp="fig:",
               fig.env="figure",
               fig.pos='!htb',
               fig.path='figures-knitr/',  # a unique ID here if you got
               cache.path='cache-knitr/',  # many documents in one dir
               cache=TRUE,
               tidy=FALSE,
               dev='tikz',
               external=TRUE,
               fig.align='center',
               size='small'
           )

options(tikzDefaultEngine = "pdftex")

options(tikzLatexPackages = c(
            "\\usepackage{amsmath,amssymb,amsfonts}",
            "\\usepackage{siunitx}",
            "\\usepackage[utf8]{inputenc}",
            "\\usepackage[english,polish]{babel}",
            "\\selectlanguage{polish}",
            "\\usepackage{tikz}",
            "\\usetikzlibrary{calc}",
            "\\usepackage{standalone}"
        ))

options(tikzMetricsDictionary="~/R/tikzMetrics") # speeds tikz up

options(tikzDocumentDeclaration = "\\documentclass[10pt]{standalone}\n")

options(tikzMetricPackages = c(
            "\\usetikzlibrary{calc}",
            "\\usepackage[utf8]{inputenc}",
            "\\usepackage[english,polish]{babel}",
            "\\selectlanguage{polish}"
        ))


knit_theme$set(knit_theme$get("default"))
@ 

%---------------------------------------------------------------------------

\author{\Sexpr{author}}

\makeatletter%
\@ifclassloaded{aghdpl}{
  \address{\Sexpr{shortAuthor}}
  \sex{m} % Mężczyzna - m; kobieta - cokolwiek
  \shortauthor{\Sexpr{shortAuthor}}
  \albumnum{279253}

  \titlePL{Analiza porównawcza wybranych cech pakietów obliczeniowych w~perspektywie ogólnoakustycznej}
  \titleEN{Comparative analysis of choosen properties of numerical computing environments in the acoustic perspective}

  \shorttitlePL{Porównanie pakietów obliczeniowych w akustyce} % skrócona wersja tytułu jeśli jest bardzo długi
  \shorttitleEN{Comparison of numerical computing environments in acoustics}

  % rodzaj pracy bez końcówki fleksyjnej np. inżyniersk, magistersk
  \thesistypePL{inżyniersk}
  \thesistypeEN{engineer}

  \supervisor{Dr inż. Bartłomiej Borkowski}

  \reviewer{prof. dr hab. inż. Jerzy Wiciak}

  \degreeprogrammePL{Inżynieria Akustyczna}
  \degreeprogrammeEN{Acoustic Engineering}

  \specialisationPL{{[}Nazwa specjalności]}
  \specialisationEN{{[}Specialisation]}

  \graduationyear{2017}
  \years{2017/2018}
  \yearofstudy{IV}

  \department{Katedra Mechaniki i Wibroakustyki}
  % \department{Department of Applied Computer Science}

  \facultyPL{Wydział Inżynierii Mechanicznej i Robotyki}
  \facultyEN{Faculty of Mechanical Engineering and Robotics}

  \thesisplan{ % Przykładowy plan pracy, należy omówić z promotorem
    \begin{enumerate}
    \item Omówienie tematu pracy i sposobu realizacji z promotorem.
    \item Zebranie i opracowanie literatury dotyczącej tematu pracy.
    \item Zebranie i opracowanie wyników badań.
    \item Analiza wyników badań, ich omówienie i zatwierdzenie przez promotora.
    \item Opracowanie redakcyjne.
    \end{enumerate}
  }

  \summaryPL{{[}Treść streszczenia]}
  \summaryEN{{[}Summary text]}

  \acknowledgements{Serdecznie dziękuję \dots tu ciąg dalszych podziękowań np. dla promotora, żony, sąsiada itp.}
  \setlength{\cftsecnumwidth}{10mm}
}{}%
\makeatother%

\date{\today}

%---------------------------------------------------------------------------
\setcounter{secnumdepth}{4}
\brokenpenalty=10000\relax

\begin{document}

\titlepages

% Ponowne zdefiniowanie stylu `plain`, aby usunąć numer strony z pierwszej strony spisu treści i poszczególnych rozdziałów.
\fancypagestyle{plain}
{
  % Usuń nagłówek i stopkę
  \fancyhf{}
  % Usuń linie.
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}
}

\setcounter{tocdepth}{2}
\tableofcontents
\clearpage

\chapter{Wprowadzenie i cel pracy}
\label{cha:wstep}
Jaka jest akustyka, każdy widzi\cite{Lam92}.

W 
\chapter{Badane pakiety obliczeniowe}
\label{cha:pakiety}

Zbadano pięć pakietów, które wybrano szczególnie ze względu na podobieństwo do MATLABa[odnośnik do alternativeto], oraz popularność[TIOBE].  

\section{Anaconda/Python}
\label{sec:anaconda}

\section{GNU Octave}
\label{sec:octave}

\section{JuliaPro/Julia}
\label{sec:julia}

\section{MATLAB}
\label{sec:matlab}

\section{Scilab}
\label{sec:scilab}

\chapter{Proces badawczy}
\label{chap:probad}

\section{Środowisko badawcze}
\label{sec:srodowisko}

W celu eliminacji wszelkich czynników, który występowanie mogłoby
wpłynąć na wiarygodność wyników przygotowano minimalne środowisko
badawcze na bazie Linuxa z patchem (łatką) CONFIG\_PREEMPT\_RT
(RTLinux), gdzie RT oznacza RealTime (czasu rzeczywistego).
Pozwala on, procesowi o wysokim priorytecie, otrzymać zasoby
komputera (czas procesora, dostęp do RAMu i dysku) w pierwszej
kolejności, przed większością procesów systemowych oraz, co jest
normalnym zachowaniem Linuxa, wszystkimi procesami o niższym
priorytecie[BIBTEX:https://lwn.net/Articles/146861/]. Dzięki temu
można mieć pewność, że żaden proces uruchomiony w tle nie spowoduje
zaniżonych wyników badań. Testy przeprowadzono na dwóch komputerach:
laptopie z ośmiowątkowym procesorem Intel\textregistered\
Core\texttrademark\ piątej generacji oraz komputerze
stacjonarnym z czterowątkowym procesorem AMD z serii 
Phenom\texttrademark\ II w celu porównania wyników na różnych
platformach.

Wykorzystano dystrybucję \emph{Arch Linux}, gdyż posiada ona
RTLinux w repozytoriach użytkowników. Wykorzystana wersja
Linuxa to 4.14.8 z patchem w wersji 9. Wykorzystane wersje
pakietów to:
\begin{itemize}%
\item Anaconda 5.01/Python 3.6.3
\item GNU Octave 4.2.1
\item JuliaPro v0.6.1.1/Julia v0.6.1
\item MATLAB R2017b
\item Scilab 6.0 (Wersja z systemu CI z 29.11.2017)
\end{itemize}%
Są to najnowsze stabilne wersję tych pakietów na dzień 29.11.2017,
poza Scilabem, którego wersja stabilna nie uruchamia się na tej
wersji Linuxa. Jest to problem w wersji 6.0, który nie został
jeszcze naprawiony. Ponadto oficjalne odnośniki do pobrania
wersji \emph{nightly} zwracają błąd 404, toteż jedyną opcją było
pobranie wersji z systemu CI (Continuous Integration -- system
automatycznej kompilacji i testowania kodu). Dodatkowo, jako że
pakiet JuliaPro nie zawiera w sobie biblioteki pozwalającej
odczytywać pliki audio, wykorzystano, wybraną ze względu na
popularność, bibliotekę \emph{WAV.jl} w wersji v0.9.0.

Do zbadania sposobu wykorzystywania zasobów komputera przez procesy 
pakietów obliczeniowych wykorzystano aplikację \emph{htop}, a do
przetwarzania i analizy danych wynikowych testów wykorzystano język
\emph{R}.

\section{System testujący}
\label{sec:systest}

Został napisany automatyczny system testujący pakiety w celu
wygodnego powtarzania testów. Składa się on z skryptu w bashu
(powłoka systemowa w większości systemów opartych na Linuxie),
który zajmuje się uruchamianiem pakietów, interpretuje
przyjmowane argumenty i przekazuje opcje do pakietów, oraz
ze skryptów w każdym z testowanych języków, które uruchamiają
testy, mierzą czas wykonania, po czym zapisują wyniki do pliku.
\begin{table}[h]%
\caption{Kod funkcji \emph{testdir}}%
\lstinputlisting[language=bash, firstline=25, lastline=54]{../tests/test.sh}%
\label{tab:testdir}%
\end{table}%
Najważniejszą częścią skryptu testującego jest funkcja \lstinline{testdir()}
(Tablica \ref{tab:testdir}),
która przyjmuje trzy argumenty: \emph{\$1} -- ścieżka do pakietu
testowanego, \emph{\$2} -- rozszerzenie plików pakietu oraz \emph{\$3} --
nazwa folderu w którym znajdują się testy. Testy muszą znajdywać
się w podfolderach i zawierać się w pliku \emph{test.\$2}. Struktura tego
pliku jest omówiona w punkcie \ref{sec:algo}, natomiast rysunek
\ref{fig:dirstruc} pokazuje jak powinna wyglądać struktura
folderów.
\begin{figure}[h]%
  \centering%
  \begin{minipage}{0.3\textwidth}%
    \dirtree{%
      .1 tests/.
      .2 test.sh.
      .2 matlab/.
      .3 tester.m.
      .3 tests/.
      .4 sin/.
      .5 test.m.
      .4 fft/.
      .5 test.m.
      .4 \dots.
      .2 julia/.
      .3 \dots.
      .2 \dots.
    }%
  \end{minipage}%
  \caption{Struktura folderów systemu testującego}%
  \label{fig:dirstruc}%
\end{figure}%
\begin{table}[h]%
  \caption{Fragment kodu pliku testującego (Julia)}%
  \lstinputlisting[language=Julia, firstline=8, lastline=17]{../tests/julia/tester.jl}%
  \label{tab:tester}%
\end{table}%
Funkcja \lstinline{testdir()} uruchamiana jest dla każdego z pakietów
z odpowiednimi argumentami, ponadto w pliku \emph{test.sh},
znajduje się tablica z globalnymi ustawieniami, które zostaną
zapisane w pliku \emph{options.\$2} i następnie wczytane przez
kod testujący w testowanym języku w pliku \emph{tester.\$2}
(Tab. \ref{tab:tester}). Skrypt \emph{test.sh} można uruchomić
z trzema argumentami, kolejno: nazwa folderu z testami
(nazwa pakietu), nazwa testu (folderu z plikiem \emph{test.\$2})
i maksymalny rząd wielkości ilości elementów wektora wejściowego.
Argumenty pierwszy i drugi przekazywane są do funkcji \lstinline{testdir()} jako
odpowiednio \lstinline{$3} i \lstinline{$TESTARG}, natomiast zmienna
\lstinline{$INPUT_SIZES}%$
zawiera szereg kolejnych potęg liczby dziesięć,
aż do maksymalnego rzędu wielkości ilości elementów wektora wejściowego.
Skrypt uruchamia każdy z pakietów za pomocą komendy \lstinline{chrt},
nadając najwyższy priorytet ich procesom, wszystkie pakiety
uruchamiane są bez interfejsu graficznego w celu zmniejszenia
czasu startowego i pominięcia jego wpływu na wydajność pakietu.
Plik testujący \emph{tester.\$2} pomija wynik pierwszego
testu by uwzględnić \emph{prekompilację} -- w celu przyspieszenia
wykonywania instrukcji część pakietów kompiluje napisany skrypt do
postaci kodu maszynowego, co może powodować nadmiarowo długi czas
wykonywania się skryptu za pierwszym razem. Każde uruchomienie
funkcji testowanej zawarte jest pomiędzy wywołaniami funkcji
mierzących czas systemowy: są to \lstinline{tic()} i \lstinline{toc()}
w MATLABie, GNU Octave i Scilabie, \lstinline{tic()} i
\lstinline{toq()} w Julii, natomiast
w Pythonie wywoływane jest \lstinline{tic=time.time()} i
\lstinline{time.time()-tic}. Po wykonaniu
odpowiedniej ilości testów (ilość ustalana jest w pliku
\emph{test.sh} i następnie przekazywana do pliku \emph{options.\$2}
jako zmienna \lstinline{number_of_tests})
zapisuje wyniki do pliku w formacie HDF5[odnośnik].
Jest to binarny format zapisu danych liczbowych w postaci
macierzy wielowymiarowych, który jest obsługiwany przez
wszystkie pakiety (do GNU Octave wymagana jest dodatkowa
biblioteka \emph{hdf5oct}[odnośnik]) i zawiera informację o strukturze, przypominającej
foldery i pliki. Wynik dla każdego rzędu wielkości zapisany jest
w oddzielnej tablicy, nazwanej numerem oznaczającym rząd wielkości,
w grupie \emph{/<test>/<pakiet>/} (Rys. \ref{fig:h5struc}).
\begin{figure}[h]%
  \centering%
  \begin{minipage}{0.3\textwidth}%
    \dirtree{%
      .1 /.
      .2 sin/.
      .3 matlab/.
      .4 1.
      .4 2.
      .4 \dots.
      .3 julia/.
      .4 \dots.
      .3 \dots.
      .2 fft/.
      .3 \dots.
      .2 \dots.
    }%
  \end{minipage}%
  \caption{Struktura wyników w pliku HDF5}%
  \label{fig:h5struc}%
\end{figure}%

\section{Badane funkcje i algorytmy}
\label{sec:algo}

Zbadano pięć funkcji, cztery biblioteczne i jedną własną.
Starano się wybrać funkcję które są koniecznym elementem 
budulcowym w aplikacjach przetwarzających sygnały audio.
Każdy test znajduje się w jednym pliku w którym muszą
znajdywać się funkcje: \lstinline{prepare_input} -- 
przygotowuje dane wejściowe dla testowanej funkcji, jako
argument przyjmuje ilość elementów wektora danych,
\lstinline{test_function} -- testowana funkcja, przyjmuje
dane przygotowane przez funkcję \lstinline{prepare_input},
przetwarza je i zwraca wynik. W kolejnych punktach zostaną
opisane pokrótce te testy wraz z przykładowym kodem
w jednym z testowanych języków. Jeśli nie jest napisane
inaczej, to w testach w pythonie korzystano z funkcji
z biblioteki \emph{NumPy}.

\subsection{Sinus}
\label{sec:sin}

Jako pierwszą zbadano, jedną z najbardziej podstawowych
funkcji matematycznych, jaką jest sinus. Jest to najprostszy
test, funkcja przygotowująca dane
tworzy tablicę punktów rozmieszczonych w równych odległościach
pomiędzy $0$, a $2\pi$, natomiast funkcja testowana wywołuje
funkcję \lstinline{sin()} na tych danych (Tab. \ref{tab:sintest}).
W teście dla pakietu \emph{Anaconda} wykorzystano bibliotekę
\emph{numexpr}, która pozwala znacznie przyspieszyć wykonywanie
prostych operacji matematycznych, jak dodawanie, mnożenie czy
właśnie obliczanie sinusa. Staje się to dzięki podziałowi
operacji na wszystkie dostępne wątki procesora i wykonywanie
równoległych obliczeń.

\begin{table}[h]%
  \caption{Kod testu \emph{sin} (Python)}%
  \lstinputlisting[language=Python, firstline=3]{../tests/python/tests/sin/test.py}%
  \label{tab:sintest}%
\end{table}%

\subsection{FFT}
\label{sec:fft}

FFT (Fast Fourier Transform) jest niezwykle istotnym algorytmem w analizie
sygnałów audio, pozwala wykonać dyskretną transformatę
Fouriera w znacznie krótszym czasie niż algorytm naiwny.

\subsubsection{Funkcja biblioteczna}
\label{sec:fftbib}

Danymi wejściowymi jest sygnał audio, będący sumą dwóch
sinusów o częstotliwościach \SI{50}{\hertz} i \SI{120}{\hertz}
oraz szumu białego, o częstotliwości próbkowania \SI{1}{\kilo\hertz}.
Funkcja testowana wywołuje na tym sygnale funkcję \lstinline{fft()}
(Tab. \ref{tab:ffttest}). Kod testu oparty jest na dokumentacji
funkcji \lstinline{fft()} dla pakietu MATLAB[odnośnik]. W pakiecie \emph{Anaconda} jest
dostępnych kilka implementacji FFT, wykorzystano tę której wyniki
były najlepsze -- \lstinline{fftpack.fft()} z biblioteki \emph{SciPy}. 
Natomiast w Julii zastosowano dyrektywę
\lstinline{FFTW.set_num_threads(Sys.CPU_CORES)}, która pozwala
wykorzystać wszystkie dostępne wątki procesora do obliczeń,
znacznie przyspieszając obliczenia[odnośnik do doumentacji].

\begin{table}[h]%
  \caption{Kod testu \emph{fft} (Python)}%
  \lstinputlisting[language=Python, firstline=2]{../tests/python/tests/fft/test.py}%
  \label{tab:ffttest}%
\end{table}%

\subsubsection{Algorytm własny}
\label{sec:fftwla}

Ważnym elementem użytkowania pakietów obliczeniowych jest
tworzenie własnych procedur, gdyż nie wszystkie
potrzebne funkcje są zawsze w bibliotekach. Aby przetestować
jak dobrze dany pakiet jest w stanie zoptymalizować
ręcznie stworzoną procedurę, napisano w każdym z języków
dokładnie tę samą funkcję. Funkcją tą jest procedura FFT
\lstinline{four1()} opisana w
\emph{Numerical Recipes in C}[Odnośnik]
(oparta na procedurze opisanej przez N. M. Brennera), przepisana
z języka C do jeżyków testowanych pakietów oraz zaadaptowana do
korzystania z natywnych typów liczb zespolonych, które
występują we wszystkich badanych pakietach. Dane wejściowe
są identyczne jak w punkcie \ref{sec:fftbib}, lecz, jako że
ta procedura operuje tylko na tablicach, których rozmiar
jest potęgą liczby dwa, są one wydłużane przez dodanie
odpowiedniej ilości zer.

Procedura \lstinline{four1()} implementuje algorytm
Cooleya-Tukeya i składa się z dwóch sekcji. Pierwsza sekcja
to pętla która zamienia miejscami elementy wektora
wejściowego w taki sposób, że gdyby ponumerować wszystkie
elementy wektora wejściowego od zera rosnąco w systemie dwójkowym, to po
zamianach ta numeracja była by malejąca, w tym celu zamieniane
są elementy wektora wejściowego które są swoim odbiciem lustrzanym
(np. 001 i 100). Druga sekcja zawiera pętle, która
wykonuje się $log_2N$ razy (gdzie $N$ to długość wektora
wejściowego). Dwie wewnętrzne pętle
wymnażają odpowiednio elementy poprzednich transformat
obliczając nową, o dwa razy większym rozmiarze. 
Każdy z elementów wektora jest jednopunktową
transformatą Fouriera, które następnie łączy się w transformaty
o długościach $2, 4, 8, \dots, N$, stosując lemat
Danielsona-Lanczosa (\ref{eq:lanczos}). 
\begin{equation}%
  F_k=F^e_k+e^{-2k\pi i/N}F^o_k
  \label{eq:lanczos}
\end{equation}%
gdzie%
\begin{eqwhere}[2cm]%
\item[$F_k$] $k$-ty punkt dyskretnej transformaty Fouriera
\item[$F_k^e$] $k$-ty punkt elementów transformaty o parzystym indeksie
\item[$F_k^o$] $k$-ty punkt elementów transformaty o nieparzystym indeksie
\end{eqwhere}%
  
\subsection{Splot}
\label{sec:splot}
  
Splot jest istotną operacją dla przetwarzania sygnałów,
gdyż pozwala on stosować filtry (FIR, IIR), oraz symulować
wpływ środowisk akustycznych na sygnał poprzez splecenie
ich odpowiedzi impulsowych z sygnałem. Funkcja testowana
wywołuje splot na dwóch tablicach z wartościami losowymi
(Tab. \ref{tab:convtest}).

\begin{table}[h]%
  \caption{Kod testu \emph{conv} (MATLAB/GNU Octave)}%
  \lstinputlisting[language=MATLAB, firstline=6]{../tests/matlab/tests/conv/test.m}%
  \label{tab:convtest}%
\end{table}%

\subsection{Wczytywanie pliku audio}
\label{sec:wavread}

Aby móc sygnał poddać obróbce należy go najpierw wczytać
do pamięci pakietu. W przypadku dużych plików, wczytywanie
może być stosunkowo długim procesem. Aby to przetestować
funkcja przygotowująca tworzy plik w formacie WAV, z
częstotliwością próbkowania \SI{48}{\kilo\hertz} i
rozdzielczością bitową \SI{16}{\bit}, o odpowiedniej liczbie
próbek, natomiast funkcja testowana wczytuje go do pamięci
(Tab. \ref{tab:wavreadtest}).
\begin{table}[h]%
  \caption{Kod testu \emph{wavread} (Scilab)}%
  \lstinputlisting[language=Scilab, firstline=3]{../tests/scilab/tests/wavread/test.sci}%
  \label{tab:wavreadtest}%
\end{table}%

\chapter{Wyniki testów}
\label{chap:wyniki}

Do przetwarzania danych wynikowych wykorzystano biblioteki
\emph{reshape2} i \emph{dplyr}[odnośniki?], natomiast
wykresy stworzono za pomocą biblioteki \emph{ggplot2}.
Na wykresie oznaczono medianę czasu wykonania procedury
testowanej oraz przedział od wartości minimalnej do
maksymalnej dla \SI{95}{\percent} najmniejszych wyników.
Pominięto \SI{5}{\percent} najwyższych wyników z powodu
ich nieporównywalnie wysokiej wartości, powodującej 
znaczne zmniejszenie czytelności wykresów. Ponieważ tego typu
wyniki, których wartość była ponad dwa razy wyższa niż
wartość średnia występowały dla wszystkich pakietów, uznano
że są one spowodowane tymczasowym niedoborem lub
spowolnieniem zasobów przez nie wykorzystywanych albo
uruchomieniem \emph{GC} (\emph{Garbage Collector} --
jest to pewna część języka programowania, która
zajmuje się oczyszczaniem pamięci ze zmiennych,
do których nie ma już odnośników w programie).

Każdy test wywoływał funkcję testowaną
\num{\Sexpr{length(results.intel$fft$octave[1,])}}
razy co
pozwoliło zminimalizować wpływ losowych czynników
niepożądanych na wyniki. Kolejne punkty zawierają
wykresy z wynikami oraz ich interpretację. W punkcie
\ref{sec:sum} znajduje się podsumowanie wyników.

\section{Sinus}
\label{sec:wynsin}

Jak można zauważyć (Rys. \ref{fig:sin.intel} i \ref{fig:sin.amd}),
zastosowanie biblioteki \emph{NumExpr} w Pythonie,
pozwala obliczyć sinus dla dużych w wektorów wejściowych,
znacznie szybciej w Anacondzie, w czasie średnio o
\SI{\Sexpr{percentFaster(results.intel$sin, "matlab", "python")}}{\percent} %$
krótszym niż MATLAB.
Różnica jest mniejsza w przypadku komputera stacjonarnego,
prawdopodobnie z powodu mniejszej ilości wątków procesora
(\SI{\Sexpr{percentFaster(results.amd$sin, "matlab", "python")}}{\percent}). %$
MATLAB jest drugi pod względem czasu wykonywania procedury
wykonując funkcję \lstinline{sin()} w średnio o
\SI{\Sexpr{percentFaster(results.intel$sin, "julia", "matlab")}}{\percent} %$
krótszym czasie niż Julia.
(\SI{\Sexpr{percentFaster(results.amd$sin, "julia", "matlab")}}{\percent} %$
dla AMD). Różnice pomiędzy Julią a GNU Octave i Scilabem są niewielkie
(\SI{\Sexpr{percentFaster(results.intel$sin, "octave", "julia")}}{\percent} %$
dla Intela i 
\SI{\Sexpr{percentFaster(results.amd$sin, "octave", "julia")}}{\percent} %$
dla AMD)
Funkcja 
W Julii funkcje takie jak \lstinline{linspace()}, lub
konstrukcje \lstinline{start:step:end} nie tworzą całych
tablic, ale specjalne obiekty których elementy są wyliczane
dopiero, gdy jest wymagany do nich dostęp[odnośnik do dokumentacji],
pozwala to przyspieszyć operacje, które nie wykorzystują
wszystkich wartości z wektora, natomiast w przypadku tego testu
działa to na niekorzyść, gdyż z każdym wywołaniem funkcji
\lstinline{sin.()} muszą być wyliczone wszystkie elementy
wektora wejściowego. Używając funkcji \lstinline{collect()}
można zamienić te obiekty na wektory. Z przeprowadzonych
krótkich testów wynikło jednak, że wpływ tego jest stosunkowo
niewielki, na poziomie \SI{10}{\percent}.

<<sin.intel, fig.cap="Wyniki testu funkcji \\lstinline{sin()} (Laptop/Intel)">>=

preparePlot(results.intel$sin)

@ 

<<sin.amd, fig.cap="Wyniki testu funkcji \\lstinline{sin()} (PC/AMD)">>=

preparePlot(results.amd$sin)

@ 

\section{FFT}
\label{sec:wynfft}

\subsection{Funkcja biblioteczna}
\label{sec:wynfftbib}

Wyniki testu funkcji \lstinline{fft()} są o tyle ciekawe,
że wszystkie pakiety, poza Anacondą, wykorzystują bibliotekę
\emph{FFTW}[odnośnik] (skrót pochodzi od
\emph{Fastest Fourier Transform in the West}) -- jest to jedna
z naszybszych bibliotek liczących transformatę Fouriera, napisana
głownie w C. Nie jest ona używana przez \emph{SciPy} z powodu
niekompatybilnych licencji, lecz istnieje możliwość wykorzystania
\emph{FFTW} w Pythonie wykorzystując bibliotekę \emph{PyFFTW}. Nie
zawiera się ona jednak w podstawowej dystrybucji Anacondy, toteż
jej nie wykorzystano do testów, choć mogłaby ona zmniejszyć
czas obliczeń. Każdy z pakietów wykorzystuje własną wersję \emph{FFTW}
z pewnymi modyfikacjami, które potrafią poprawić wydajność,
ponadto \emph{FFTW} pozwala na wykorzystanie tzw. \emph{planowania FFT}
-- jest to proces w którym biblioteka wstępnie oblicza macierz
transformacji dla danego rozmiaru FFT, co pozwala znacznie
przyspieszyć obliczanie kolejnych FFT o tym samym rozmiarze
po prostu mnożąc sygnał przez tę macierz. To, oraz fakt, że
\emph{FFTW} pozwala modyfikować wiele parametrów algorytmu
obliczania FFT, powoduje że różnice, choć nie bardzo duże,
istnieją (Rys. \ref{fig:fft.intel} i \ref{fig:fft.amd}.

Najkrócej oblicza GNU Octave w czasie średnio o
\SI{\Sexpr{percentFaster(results.intel$fft, "matlab", "octave")}}{\percent} %$
krótszym niż MATLAB, o
\SI{\Sexpr{percentFaster(results.intel$fft, "julia", "octave")}}{\percent} %$
krótszym niż Julia, o
\SI{\Sexpr{percentFaster(results.intel$fft, "python", "octave")}}{\percent} %$
krótszym niż Python i aż o
\SI{\Sexpr{percentFaster(results.intel$fft, "scilab", "octave")}}{\percent} %$
krótszym niż Scilab (odpowiednio
\SI{\Sexpr{percentFaster(results.amd$fft, "matlab", "octave")}}{\percent} %$
, \SI{\Sexpr{percentFaster(results.amd$fft, "julia", "octave")}}{\percent} %$
, \SI{\Sexpr{percentFaster(results.amd$fft, "python", "octave")}}{\percent} %$
 i \SI{\Sexpr{percentFaster(results.amd$fft, "scilab", "octave")}}{\percent} %$
dla AMD).

<<fft.intel, fig.cap="Wyniki testu funkcji \\lstinline{fft()} (Laptop/Intel)">>=

preparePlot(results.intel$fft)

@ 

<<fft.amd, fig.cap="Wyniki testu funkcji \\lstinline{fft()} (PC/AMD)">>=

preparePlot(results.amd$fft)

@ 

\subsection{Algorytm własny}
\label{sec:wynfftwla}

<<four1.intel, fig.cap="Wyniki testu funkcji \\lstinline{four1()} (Laptop/Intel)">>=

preparePlot(results.intel$four1)

@ 

<<four1.amd, fig.cap="Wyniki testu funkcji \\lstinline{four1()} (PC/AMD)">>=

preparePlot(results.amd$four1)

@ 

\section{Splot}
\label{sec:wynsplot}

<<conv.intel, fig.cap="Wyniki testu funkcji \\lstinline{conv()} (Laptop/Intel)">>=

preparePlot(results.intel$conv)

@ 

<<conv.amd, fig.cap="Wyniki testu funkcji \\lstinline{conv()} (PC/AMD)">>=

preparePlot(results.amd$conv)

@ 

\section{Wczytywanie pliku audio}
\label{sec:wynwavread}

<<wavread.intel, fig.cap="Wyniki testu funkcji \\lstinline{wavread()} (Laptop/Intel)">>=

preparePlot(results.intel$wavread)

@ 

<<wavread.amd, fig.cap="Wyniki testu funkcji \\lstinline{wavread()} (PC/AMD)">>=

preparePlot(results.amd$wavread)

@ 

\section{Sumaryczne zestawienie wyników}
\label{sec:sum}

<<summary.intel, fig.cap="Wyniki testów dla najdłuższego wektora (Laptop/Intel)">>=
summaryPlot(results.intel)

@ 

<<summary.amd, fig.cap="Wyniki testów dla najdłuższego wektora (PC/AMD)">>=
summaryPlot(results.amd)

@ 
\chapter{Podsumowanie}
\label{chap:podsumowanie}

\section{Sumaryczna analiza wyników}
\label{sec:sumanaliza}

\section{Dalsze kierunki badań}
\label{sec:kier}




%\include{aghdpl-imir/rozdzial3}
%\include{aghdpl-imir/rozdzial1}
%\include{aghdpl-imir/rozdzial2}
%\include{aghdpl-imir/tests}



% itd.
% \appendix
% \include{dodatekA}
% \include{dodatekB}
% itd.

\printbibliography

\end{document}
