\PassOptionsToPackage{binary-units=true}{siunitx}

\documentclass[pl,12pt]{aghdpl}
% \documentclass[en,11pt]{aghdpl}  % praca w języku angielskim

% Lista wszystkich języków stanowiących języki pozycji bibliograficznych użytych w pracy.
% (Zgodnie z zasadami tworzenia bibliografii każda pozycja powinna zostać utworzona zgodnie z zasadami języka, w którym dana publikacja została napisana.)
\usepackage[english,polish]{babel}

% Użyj polskiego łamania wyrazów (zamiast domyślnego angielskiego).
\usepackage{polski}

\usepackage[utf8]{inputenc}

\usepackage[T1]{fontenc}

% Załączniki

\usepackage[toc, page]{appendix}
\renewcommand\appendixpagename{Załączniki}
\renewcommand\appendixtocname{Załączniki}

% dodatkowe pakiety

\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{float}% do umieszczenia floatów [h]
\usepackage{enumitem}
\setlist{nosep} % or \setlist{noitemsep} to leave space around whole list
\usepackage[bookmarks,hidelinks]{hyperref}

% float do kodu

\floatstyle{plaintop}
\ifcsname{chapter}\endcsname%
    \newfloat{program}{!tbh}{lop}[chapter]
\else%
    \newfloat{program}{!tbh}{lop}
\fi
\floatname{program}{Kod źr.}

% floaty w sekcji w które są stworzone

\usepackage{placeins}

\ifcsname{chapter}\endcsname%
    \let\Oldchapter\chapter
    \renewcommand{\chapter}{\FloatBarrier\Oldchapter}
\fi

\let\Oldsection\section
\renewcommand{\section}{\FloatBarrier\Oldsection}

\let\Oldsubsection\subsection
\renewcommand{\subsection}{\FloatBarrier\Oldsubsection}

\let\Oldsubsubsection\subsubsection
\renewcommand{\subsubsection}{\FloatBarrier\Oldsubsubsection}

% specjalistyczne pakiety

\usepackage{dirtree}% Drzewo folderów
\usepackage[full]{textcomp}% Symbole trademark, registered...

% --- < bibliografia > --


\usepackage[
style=numeric,
sorting=none,
% 
% Zastosuj styl wpisu bibliograficznego właściwy językowi publikacji.
language=autobib,
autolang=other,
% Zapisuj datę dostępu do strony WWW w formacie RRRR-MM-DD.
urldate=edtf,
seconds=true,
% Nie dodawaj numerów stron, na których występuje cytowanie.
backref=false,
% Podawaj ISBN.
isbn=true,
% Nie podawaj URL-i, o ile nie jest to konieczne.
url=false,
% 
% Ustawienia związane z polskimi normami dla bibliografii.
maxbibnames=3,
% Jeżeli używamy Bibera:
backend=biber
]{biblatex}

\usepackage{csquotes}
% Ponieważ `csquotes` nie posiada polskiego stylu, można skorzystać z mocno zbliżonego stylu chorwackiego.
\DeclareQuoteAlias{croatian}{polish}

\addbibresource{bibliografia.bib}

% Nie wyświetlaj wybranych pól.
% \AtEveryBibitem{\clearfield{note}}

% ------------------------
% --- < listingi > ---

% Użyj czcionki kroju Times.
\usepackage{newtxtext}
\usepackage{newtxmath}

\usepackage{listings}
\lstloadlanguages{MATLAB}

\lstset{%
  literate={ą}{{\k{a}}}1
  {ć}{{\'c}}1
  {ę}{{\k{e}}}1
  {ó}{{\'o}}1
  {ń}{{\'n}}1
  {ł}{{\l{}}}1
  {ś}{{\'s}}1
  {ź}{{\'z}}1
  {ż}{{\.z}}1
  {Ą}{{\k{A}}}1
  {Ć}{{\'C}}1
  {Ę}{{\k{E}}}1
  {Ó}{{\'O}}1
  {Ń}{{\'N}}1
  {Ł}{{\L{}}}1
  {Ś}{{\'S}}1
  {Ź}{{\'Z}}1
  {Ż}{{\.Z}}1
}

\usepackage{color}

% --- < kolorowanie kodu > ---

% From overleaf.com
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},     % choose the background color
  basicstyle=\ttfamily\footnotesize, % size of fonts used for the code
  breaklines, breakatwhitespace,     % automatic line breaking only at whitespace
  commentstyle=\color{mygreen},      % comment style
  numbers=left,
  showstringspaces=false,
  numberstyle=\tiny,
  frame=l,
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  keywordstyle=\color{blue},         % keyword style
  stringstyle=\color{mymauve}        % string literal style
}

%%
%% Julia definition (c) 2014 Jubobs
%%
\lstdefinelanguage{Julia}%
  {morekeywords={abstract,break,case,catch,const,continue,do,else,elseif,%
      end,export,false,for,function,immutable,import,importall,if,in,%
      macro,module,otherwise,quote,return,switch,true,try,type,typealias,%
      using,while,begin,where},%
   sensitive=true,%
   alsoother={$},%$
   morecomment=[l]\#,%
   morecomment=[n]{\#=}{=\#},%
   morestring=[s]{"}{"},%
   morestring=[m]{'}{'},%
}[keywords,comments,strings]%
% ------------------------

\AtBeginDocument{
  \renewcommand{\tablename}{Tab.}
  \renewcommand{\figurename}{Rys.}
}

% ------------------------
% --- < tabele > ---

\usepackage{array}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage[flushleft]{threeparttable}

% defines the X column to use m (\parbox[c]) instead of p (`parbox[t]`)
\newcolumntype{C}[1]{>{\hsize=#1\hsize\centering\arraybackslash}X}

% --------------------------Ustawienia Knitr---------------------------------

<<Opcje globalne, include=FALSE>>=
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
knitr::opts_knit$set(concordance = TRUE);

Sys.setlocale(category = 'LC_ALL','en_US.UTF-8')
Sys.setenv(LANG="EN")
Sys.setlocale("LC_TIME","C")
@ 

%--------------------------Funkcje------------------------------------------

<<Funkcje>>=
library(h5)
library(ggplot2)
library(reshape2)
library(dplyr)

packages <- c("julia","octave","matlab","python","scilab")
tests <- c("sin", "conv", "fft", "four1", "wavread")

rowMax <- function(x, shaveoffpercent=5) {
    apply(x, 1, function(e) {
        max(shaveoff(e, shaveoffpercent), na.rm=TRUE)
    })
}

rowMin <- function(x) {
    apply(x, 1, function(e) {
        min(e, na.rm=TRUE)
    })
}

rowMedian <- function(x) {
    apply(x, 1, function(e) {
        median(e, na.rm=TRUE)
    })
}

rowCountNA  <- function(x) {
    apply(x, 1, function(e) {
        sum(is.na(e))/length(e)
    })
}

shaveoff  <- function(vec, percent) {
    vec[-tail(order(vec), floor(percent*length(vec)/100))]
}

getResults <- function(h5df_file) {
    results <- list()
    for (test_name in tests) {
        results[[test_name]] <- list()
        max_input_size <- length(list.datasets(h5df_file[test_name]["octave"]))
        for (package in packages) {
            number_of_tests  <- length(h5df_file[test_name][package]["1"][])
            results[[test_name]][[package]] <- matrix(NA,max_input_size,number_of_tests)
            for (input_size in 1:max_input_size) {
                res <- as.vector(h5df_file[test_name][package][toString(input_size)][])
                results[[test_name]][[package]][input_size,1:length(res)] <- res
            }
        }
    }
    results
}

preparePlot <- function(res) {
    means <- lapply(res, rowMedian)
    mins <- lapply(res, rowMin)
    maxs <- lapply(res, rowMax)

    means.molten <- as.data.frame(melt(means) %>% group_by(L1) %>% mutate(id = row_number()))
    mins.molten <- as.data.frame(melt(mins) %>% group_by(L1) %>% mutate(id = row_number()))
    maxs.molten <- as.data.frame(melt(maxs) %>% group_by(L1) %>% mutate(id = row_number()))

    means.molten["VectorSize"] <- 10^means.molten["id"]

    plot <- ggplot(means.molten, aes(x=VectorSize, y=value, colour=L1)) 
    plot <- plot + geom_errorbar(aes(ymin=mins.molten["value"], ymax=maxs.molten["value"]), width=.1)
    plot <- plot + scale_y_log10() + scale_x_log10() + geom_point() + geom_line()
    plot <- plot + xlab("Ilo\\'s\\'c element\\'ow wektora wej\\'sciowego")
    plot <- plot + ylab("Czas wykonywania procedury [$\\si{\\second}$]")
    plot <- plot + labs(colour="Pakiet obliczeniowy")
    plot <- plot + theme_bw() + theme(legend.position=c(0.01,0.99), legend.justification=c(0.01,0.99))
    plot
}

summaryMelt <- function(res, func) {
    as.data.frame(melt(lapply(res, function(package) {
        melt(lapply(package, function(x) {
            fff <- func(x)
            tens <- 10^(1:length(fff))
            sum(fff*tens)/sum(tens)
        }))
    })) %>% group_by(L1) %>% mutate(id = packages[row_number()]))
}

summaryPlot <- function(res) {
    sumres <- summaryMelt(res, rowMedian)
    summax <- summaryMelt(res, rowMax)
    summin <- summaryMelt(res, rowMin)

    plot <- ggplot(sumres, aes(x=L1, y=value, colour=id)) 
    plot <- plot + geom_point() + theme_bw() + scale_y_sqrt()
    plot <- plot + geom_errorbar(aes(ymin=summin["value"], ymax=summax["value"]), width=.1)
    plot <- plot + ylab("Czas wykonywania procedury [$\\si{\\second}$]")
    plot <- plot + xlab("Testowana funkcja")
    plot <- plot + labs(colour="Pakiet obliczeniowy")
    plot
}

percentFaster <- function(res, name1, name2) {
    means <- rowMeans(res[[name1]])/rowMeans(res[[name2]])
    tenseq <- 5^(1:length(means))
    round(100 - 100*sum(tenseq)/sum(means*tenseq), 1)
}
@ 
%----------------------------Zmienne----------------------------------------

<<Inicjalizacja zmiennych>>=
author <- "Szymon Mikulicz"
shortAuthor <- paste(substr(author,1,1),'. ',unlist(strsplit(author,'[ ]'))[2],sep='')

results.file <- h5file("../tests/results.amd.h5", "r")
results.amd <- getResults(results.file)
h5close(results.file)

results.file <- h5file("../tests/results.intel.h5", "r")
results.intel <- getResults(results.file)
h5close(results.file)
@ 

%-------------------------Ustawienia TikzDevice---------------------------

<<tikzSettings>>=
options(width=71)
options(digits=7)

require("knitr")

opts_chunk$set(
               keep.source=TRUE,
               out.width='5in',
               fig.width=5,
               fig.height=5/sqrt(2),
               fig.lp="fig:",
               fig.env="figure",
               fig.pos='!htb',
               fig.path='figures-knitr/',  # a unique ID here if you got
               cache.path='cache-knitr/',  # many documents in one dir
               cache=TRUE,
               tidy=FALSE,
               dev='tikz',
               external=TRUE,
               fig.align='center',
               size='small'
           )

options(tikzDefaultEngine = "pdftex")

options(tikzLatexPackages = c(
            "\\usepackage{amsmath,amssymb,amsfonts}",
            "\\usepackage{siunitx}",
            "\\usepackage[utf8]{inputenc}",
            "\\usepackage[english,polish]{babel}",
            "\\selectlanguage{polish}",
            "\\usepackage{tikz}",
            "\\usetikzlibrary{calc}",
            "\\usepackage{standalone}"
        ))

options(tikzMetricsDictionary="~/R/tikzMetrics") # speeds tikz up

options(tikzDocumentDeclaration = "\\documentclass[10pt]{standalone}\n")

options(tikzMetricPackages = c(
            "\\usetikzlibrary{calc}",
            "\\usepackage[utf8]{inputenc}",
            "\\usepackage[english,polish]{babel}",
            "\\selectlanguage{polish}"
        ))


knit_theme$set(knit_theme$get("default"))
@ 

%---------------------------------------------------------------------------

\author{\Sexpr{author}}

\makeatletter%
\@ifclassloaded{aghdpl}{
  \address{Legionów 49, 05-220 Zielonka}
  \sex{m} % Mężczyzna - m; kobieta - cokolwiek
  \shortauthor{\Sexpr{shortAuthor}}
  \albumnum{279253}

  \titlePL{Analiza porównawcza wybranych cech pakietów obliczeniowych w perspektywie ogólnoakustycznej}
  \titleEN{Comparative analysis of choosen properties of numerical computing environments in the acoustic perspective}

  \shorttitlePL{Porównanie pakietów obliczeniowych w akustyce} % skrócona wersja tytułu jeśli jest bardzo długi
  \shorttitleEN{Comparison of numerical computing environments in acoustics}

  % rodzaj pracy bez końcówki fleksyjnej np. inżyniersk, magistersk
  \thesistypePL{inżyniersk}
  \thesistypeEN{engineer}

  \supervisor{Dr inż. Bartłomiej Borkowski}

  \reviewer{prof. dr hab. inż. Jerzy Wiciak}

  \degreeprogrammePL{Inżynieria Akustyczna}
  \degreeprogrammeEN{Acoustic Engineering}

  \specialisationPL{Drgania i hałas w technice i środowisku}
  \specialisationEN{{[}Specialisation]}

  \graduationyear{2017}
  \years{2017/2018}
  \yearofstudy{IV}

  \department{Katedra Mechaniki i Wibroakustyki}
  % \department{Department of Applied Computer Science}

  \facultyPL{Wydział Inżynierii Mechanicznej i Robotyki}
  \facultyEN{Faculty of Mechanical Engineering and Robotics}

  \thesisplan{ % Przykładowy plan pracy, należy omówić z promotorem
    \begin{enumerate}
    \item Omówienie tematu pracy i sposobu realizacji z promotorem.
    \item Zebranie i opracowanie literatury dotyczącej tematu pracy.
    \item Zebranie i opracowanie wyników badań.
    \item Analiza wyników badań, ich omówienie i zatwierdzenie przez promotora.
    \item Opracowanie redakcyjne.
    \end{enumerate}
  }

  \summaryPL{{[}Treść streszczenia]}
  \summaryEN{{[}Summary text]}

  \acknowledgements{Serdecznie dziękuję \dots tu ciąg dalszych podziękowań np. dla promotora, żony, sąsiada itp.}
  \setlength{\cftsecnumwidth}{10mm}
}{}%
\makeatother%

\date{\today}

%---------------------------------------------------------------------------
\setcounter{secnumdepth}{4}
\brokenpenalty=10000\relax

\begin{document}

\titlepages

% Ponowne zdefiniowanie stylu `plain`, aby usunąć numer strony z pierwszej strony spisu treści i poszczególnych rozdziałów.
\fancypagestyle{plain}
{
  % Usuń nagłówek i stopkę
  \fancyhf{}
  % Usuń linie.
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}
}

\setcounter{tocdepth}{2}
{\singlespacing\tableofcontents}
\clearpage

\chapter{Wprowadzenie}
\label{cha:wstep}

Przeprowadzanie obliczeń numerycznych jest istotnym elementem
pracy z sygnałami. W szczególności w akustyce analiza sygnałów
dźwiękowych wymaga przetworzenia ich, stosując układy i algorytmy
pozwalające wydobyć z nich odpowiednie informacje. Choć jest to
możliwe za pomocą dedykowanych urządzeń analogowych lub cyfrowych,
wykorzystanie pakietu obliczeniowego pozwala na większe możliwości
modyfikacji działania systemu przetwarzającego oraz zaprojektowanie
systemu, którego działanie nie jest dostępne w innej postaci.
Możliwości szybkiego prototypowania dostarczane przez te narzędzia
są szczególnie przydatne w fazie poszukiwań nowych sposobów na
ekstrakcję informacji z analizowanych sygnałów. Narzędzia te umożliwiają
także obrazowanie sygnałów poprzez funkcjonalność rysującą,
czy to wykresy parametrów lub funkcji, czy bardziej zaawansowanych
wizualizacji, takich jak spektrogram.

Przetwarzanie sygnałów, nie jest, jednak, jedyną dziedziną akustyki
w której pakiety obliczeniowe znajdują zastosowanie. W istocie, w
dziedzinie akustyki teoretycznej, pozwalają one przeprowadzać
symulacje fizyczne skomplikowanych układów akustycznych oraz
wizualizację rozkładu parametrów akustycznych w takim układzie.
Znajdują także zastosowanie w dziedzinie symulacji i rozwiązywania
układów mechanicznych takich jak układy tłumiące wibracje.

Jednym z pierwszych pakietów obliczeniowych, które
oferowały bogatą bibliotekę funkcji podstawowych i
łatwy do przyswojenia język programowania był MATLAB
(patrz punkt \ref{sec:matlab}). Jego wygoda użytkowania
w stosunku do uprzednio używanych rozwiązań spowodowała,
że stał się on jednym z najczęściej wykorzystywanych pakietów w
środowisku naukowym. Od tego czasu, jednak, powstało wiele innych
pakietów konkurujących z~nim pod względem funkcjonalności
jak i prędkości wykonywanych obliczeń. W tej pracy podjęto
się krótkiego porównania działania MATLABa oraz jego
najpoważniejszych konkurentów, których funkcjonalność
pozwala na użytkowanie w celach związanych z szeroko
pojęta akustyką.

Podobne badania były przeprowadzane między innymi w dziedzinach
inżynierii chemicznej\cite{ComparisonSix} oraz przetwarzania
obrazów\cite{ComparativeStudy}, jak i bez skupiania się na jednej
dziedzinie, a w postaci ogólnej\cite{ComparativeEvaluation,StudyFree}.

\section{Cel pracy}
\label{sec:cel}

Celem pracy jest wprowadzenie w działanie i funkcjonalność
wybranych pakietów obliczeniowych oraz przeprowadzenie
testów porównujących szybkość wykonywania
wybranych podstawowych funkcji związanych z akustyką i
przetwarzaniem sygnałów, poprzez skonstruowanie i
utylizację automatycznego systemu testującego, którego
działanie pozwoli niewielkim nakładem pracy rozszerzyć
ilość testów i testowanych pakietów, w~nadziei, że
ta analiza pozwoli dokonać wyboru pakietu do danego
zadania lub znaleźć alternatywę dla obecnie używanego.
Za wymóg wiarygodności testów uznano
powtarzalność wyników i możliwie jak najniższy 
wpływ czynników zewnętrznych na nie.

\section{Zawartość pracy}
\label{sec:zawartosc}

W rozdziale nr \ref{cha:pakiety} znajdują się opisy badanych
pakietów. W każdym opisie znajduje się krótkie wprowadzenie
w jego funkcjonalność oraz najważniejsze różnice w działaniu
i~korzystaniu między tym pakietem a pozostałymi. Znajdują się
tam: opis możliwości rozszerzenia funkcjonalności pakietów,
działanie i możliwości systemu do tworzenia wykresów,
sposoby interakcji i korzystania z pakietu,
opis korzystania z języka programowania w~pakiecie
wraz z przykładowym kodem oraz inne uwagi, które uznano za istotne.

Rozdział nr \ref{chap:probad} opisuje środowisko badawcze
w którym zostały przeprowadzone badania, w tym: wykorzystane
platformy sprzętowe, system operacyjny i jego modyfikacje, 
wersje badanych pakietów oraz narzędzie wykorzystane do
ich analizy. Następnie opisany jest system użyty do
przeprowadzenia testów, wraz z opisem: skryptów na który
się składa, wymaganej struktury folderów, mechanizmu
pozwalającego mierzyć czas w~każdym z pakietów oraz
rodzaju i struktury pliku do którego zapisywane są wyniki.
Finalnie zamieszczony jest opis wszystkich przeprowadzonych
testów wraz z uzasadnieniem wyboru, opisem działania kodu i
ewentualnymi uwagami dotyczącymi zastosowanych lub niezastosowanych 
elementów danego języka.

Rozdział nr \ref{chap:wyniki} zawiera
wyniki uzyskane podczas testów w formie wykresów oraz
analizę wyników wraz z ewentualnymi uwagami dotyczącymi
możliwych do podjęcia kroków w celu możliwego poprawienia
uzyskanych wyników. Ostatni punkt w tym rozdziale zawiera
wykresy podsumowujące całościowo wyniki, jak również
sumaryczną analizę porównawczą całości badań.

Rozdział nr \ref{chap:podsumowanie} stanowi podsumowanie
wyników i informacji na temat możliwości pakietów
oraz zestawienie możliwych do
podjęcia badań eksplorujących badane zagadnienie w
większym stopniu.

\chapter{Badane pakiety obliczeniowe}
\label{cha:pakiety}

Badaniami objęto pięć pakietów. Głównym kryterium, którym się kierowano
przy wyborze była popularność języka programowania używanego w
danym pakiecie\cite{TIOBE,PyPl}, co przekłada się na łatwość
znalezienia publikacji i pomocy dotyczących tego języka oraz ilość bibliotek
poszerzających funkcjonalność. Ponadto ograniczono się tylko do pakietów
które, podobnie jak MATLAB, są ogólnego, choć związanego z nauką,
przeznaczenia i~które posiadają podobną funkcjonalność w dziedzinie
przetwarzania sygnałów.

\section{MATLAB}
\label{sec:matlab}
\lstset{language=MATLAB}

MATLAB\cite{MATLAB} to skryptowy język programowania i środowisko do
obliczeń numerycznych w szczególności
związanych z zagadnieniami naukowo-technicznymi tworzone przez firmę
\emph{MathWorks}. Zarówno język jak i aplikacją są prawnie zastrzeżone
i wymagają stosunkowo drogiej licencji do użytkowania.

MATLAB, jest trzecim najpopularniejszym
językiem wśród języków testowanych pakietów oraz jest w pierwszej
dwudziestce najpopularniejszych języków programowania. To oraz fakt
bycia najstarszym językiem wśród testowanych powoduje łatwość znalezienia
publikacji oraz pomocy na jego temat. Ponadto posiada on dokumentację
na bardzo wysokim poziomie.

Zwiększenie możliwości MATLABa odbywa się poprzez dokupienie dodatkowych
bibliotek grupujących zaawansowaną funkcjonalność z danej dziedziny
nauki zwanych \emph{toolboxami}. Co więcej wykorzystując możliwość
instalacji dodatków dostępną z interfejsu graficznego można zainstalować
biblioteki poszerzające wsparcie sprzętowe oraz funkcje, skrypty i
aplikacje stworzone przez użytkowników MATLABa znajdujące się
na platformie \emph{File Exchange}.

MATLAB posiada własny silnik rysujący, który pozwala rysować wykresu dwu-
i~trójwymiarowe na podstawie danych numerycznych. Jest to możliwe zarówno
przy
pomocy interfejsu graficznego, zaznaczając odpowiednie zmienne, jak i przy
pomocy funkcji \lstinline|plot()|, która w najprostszym przypadku
przyjmuje dwa wektory, zawierające odpowiednio współrzędne
osi poziomej i pionowej punktów pożądanego wykresu.
Modyfikacja wyglądu wykresu oraz umieszczanie na nim tekstu odbywa się
poprzez narzędzie graficzne \emph{Plot Tools} lub przez odpowiednie
funkcje, takie jak: \lstinline|title()| -- pozwalającą
ustalić tytuł wykresu, czy \lstinline|subplot()| -- pozwalającą
na podział okna, by móc w nim umieścić kilka wykresów obok siebie.

Praca w środowisku MATLAB odbywa się głównie przy pomocy graficznego
zintegrowanego środowiska programistycznego, które jest domyślnym
interfejsem pakietu. Posiada ono edytor kodu źródłowego, przeglądarkę
plików, inspektor zmiennych, konsolę wiersza poleceń i przeglądarkę
dokumentacji. Środowisko graficzne MATLABa jest bardzo rozbudowane
i zawiera wiele narzędzi graficznych ułatwiających początkującym
stosowanie zaawansowanej funkcjonalności, takiej jak projektowanie filtrów
i aproksymacja funkcji. Istnieje też możliwość uruchomienia MATLABa
bez środowiska graficznego, lecz z ograniczoną funkcjonalnością,
gdyż nie ma on wtedy możliwości modyfikacji preferencji, rysowania
wykresów ani tworzenia i korzystania z aplikacji graficznych.

%Aby się nie rozwodzić za długo nad pięknem MATLABa, wstrzymano
%się od opisu jego smukłych tabelek i zgrabnych krągłości wykresów,
%gdyż taka introspekcja mogła by odkryć niespodziewaną głębie
%sensualności pakietu i zawstydzić Szanownych Czytelników.

Język programowania, który jest głównym narzędziem pracy w pakiecie
MATLAB, został stworzony w celu uproszenia przeprowadzania programowych
obliczeń numerycznych oferując składnie mocno zbliżoną
do notacji matematycznej oraz dynamiczny system typów zmiennych.
Pozwala to na szybkie pisanie kodu, który będzie czytelny i
zrozumiały. W tym celu MATLAB posiada dużą ilość funkcji
matematycznych (\lstinline|sin()|, \lstinline|log()|, \dots)
oraz wbudowanych stałych matematycznych (\lstinline|pi|,
\lstinline|e|, \dots).

Poza zmiennymi numerycznymi, podstawowym typem zmiennej jest macierz,
konstruowana przy pomocy nawiasów kwadratowych w których
umieszcza się elementy oddzielone przecinkami lub spacjami -- co łączy
je w~rzędy, albo średnikami -- co łączy je w~kolumny. Przykładowo
instrukcja \lstinline|A = [1, 2; 3, 4]| stworzy macierz:
$$A = \begin{bmatrix}
         1 & 2 \\
         3 & 4
       \end{bmatrix}$$%
Nawiasy kwadratowe służą również do łączenie macierzy; powyższemu zapisowi
odpowiada \lstinline|A = [[1, 2]; [3, 4]]| -- dwa wektory są
łączone w dwuwierszową macierz.
Aby wydobyć element macierzy należy wykorzystać nawiasy okrągłe
i podać w nich współrzędne położenia elementu, które są odpowiednio
numerem rzędu i kolumny. Polecenie \lstinline|A(1,2)| zwróci
wartość z pierwszego rzędu i drugiej kolumny macierzy 
\lstinline|A|, czyli, w tym przypadku, \lstinline|2|. Indeksowanie
jest możliwe
także operatorem \lstinline|:| (dwukropkiem), wtedy zwracane są
elementy ze wszystkich kolumn lub wierszy (np. \lstinline|A(1,:)|
zwróci macierz \lstinline|[1, 2]|. Dwukropek może być
też użyty do tworzenia sekwencji liczb w postaci
\lstinline|start:krok:koniec|, gdzie, jeżeli krok nie zostanie podany,
to przyjmuje wartość 1 (np. \lstinline|0:0.1:pi| stworzy
sekwencję $0, \num{0.1}, \num{0.2}, \dots, \pi$), czego również można
użyć do indeksowania macierzy (np. \lstinline|A(1, 1:2)| zwróci
od pierwszego do drugiego elementu z pierwszego rzędu).
Operatory arytmetyczne
działają na macierzach zgodnie z zapisem algebraicznym
(mnożenie jest mnożeniem macierzowym i podobnie), by wykonać operację
arytmetyczną na każdym elemencie macierzy z osobna należy wykorzystać
specjalne operatory z kropkami (\lstinline|.*|, \lstinline|.^|, \dots).
Funkcje działające na pojedynczych liczbach przetwarzają macierze
operując na każdym elemencie niezależnie. 

Typem zmiennej zawierającej tekst są tablice znaków, tworzone
przy użyciu apostrofów, na przykład \lstinline|zwierze = 'kot'|, co oznacza
to samo co \lstinline|zwierze = ['k', 'o', 't']| -- wektor znaków.
Istnieje również typ zmiennej tekstowej \emph{string}, tworzony
przy użyciu cudzysłowów (\lstinline|zwierze = "kot"|), który
pozwala na traktowanie tekstu inaczej niż wektora znaków i
posiada własny zestaw funkcji operujących na nim.

Definicję funkcji rozpoczyna się słowem kluczowym \lstinline|function|
po czym należy zapisać jej parametry wyjściowe i wejściowe w postaci
\lstinline|y = funkcja(x)|, gdzie \lstinline|x| jest argumentem
funkcji, a \lstinline|y| parametrem wyjściowym (Kod żr. \ref{tab:abs.m}).
Funkcję można wywołać na dwa sposoby, albo w formie funkcji --
\lstinline|funkcja(x)|, albo, jeżeli funkcja nie zwraca żadnych wartości,
a jej argumenty są tablicami znaków, w formie komendy -- \lstinline|funkcja x|,
co jest odpowiednikiem \lstinline|funkcja('x')|. Funkcje mogą zwracać
więcej niż jedną zmienną, oraz przyjmować wiele argumentów przy użyciu
zapisu \lstinline|[y1, y2] = funkcja(x1, x2)| w~definicji funkcji. Taki
sam zapis należy stosować przy wywołaniu, w przeciwnym wypadku uzyska się
wyłącznie pierwszą zmienną z wektora zwracanych. Istnieje możliwość
zignorowania części zmiennych wyjściowych funkcji stosując operator
\lstinline|~| (tyldę) zamiast zmiennych (np.
\lstinline|[~, y2] = funkcja(x1, x2)|).

\begin{program}
  \caption{Funkcja licząca moduł liczby rzeczywistej (MATLAB)}
  \begin{lstlisting}
function y = modul(x)
    if x < 0
        y = -x;
    else
        y = x;
    end
end
  \end{lstlisting}
  \label{tab:abs.m}
\end{program}

Do tworzenia instrukcji warunkowych służą słowa kluczowe \lstinline|if|,
\lstinline|elseif|, \lstinline|else| i \lstinline|end|. Jeżeli warunek po słowie \lstinline|if|
jest spełniony to kolejny blok kodu się wykonuje, w przeciwnym przypadku
sprawdzany zostaje warunek po \lstinline|elseif|, jeżeli żaden nie jest spełniony
wykonywane są instrukcje po \lstinline|else| zakończone słowem kluczowym
\lstinline|end| (Kod żr. \ref{tab:abs.m}). Aby konstrukcja była poprawna nie
jest wymagane wykorzystanie elementów \lstinline|else| i \lstinline|elseif|.

W języku istnieją dwa rodzaje pętli. Pętla \emph{while} wykonuje blok kodu
do słowa kluczowego \lstinline|end|, dopóki warunek po słowie kluczowym
\lstinline|while| jest spełniony. Natomiast pętla \emph{for} wykonuje się
dla każdego elementu wektora po prawej stronie znaku równości w konstrukcji
\lstinline|it = start:krok:stop| po słowie kluczowym \lstinline|for|.

\section{GNU Octave}
\label{sec:octave}
\lstset{language=Octave}

GNU Octave\cite{Octave} to darmowy i otwartoźródłowy (pod licencją GPL)
skryptowy język programowania do
zastosowań techniczno-naukowych tworzony jako część systemu operacyjnego
GNU. Jest tworzony przez wolontariuszy i sponsorowany przez FSF
(\emph{Free Software Foundation}), jako alternatywa dla MATLABa.

GNU Octave posiada wiele bibliotek, których większość znajduje się w repozytorium
o nazwie \emph{Octave-Forge}. Biblioteki te grupują funkcje związane z dziedzinami
nauki, podobnie jak \emph{toolboxy} w MATLABie, choć często ich funkcjonalność
nie jest aż tak zaawansowana. Aby zainstalować bibliotekę, należy ją pobrać
ze strony \emph{Octave-Forge}, po czym wywołać komendę
\lstinline{pkg install <nazwa pobranego archiwum>} lub bezpośrednio
wywołać komendę \lstinline{pkg install -forge <nazwa biblioteki>}, która
to zrobi automatycznie. Aby bibliotekę wykorzystać potem w skrypcie lub
linii poleceń należy ją wczytać poleceniem \lstinline{pkg load <nazwa bibiloteki>}.

Octave posiada bogatą bibliotekę podstawową, która zawiera większość funkcji
będących także w bibliotece podstawowej MATLABa. Najważniejszą biblioteką która
poszerza jej funkcjonalność w dziedzinie przetwarzania sygnałów jest
\emph{signal} -- odpowiednik \emph{Signal Processing Toolbox} w
MATLABie. Zawiera funkcje do: tworzenia i filtrowania sygnałów, tworzenia
filtrów typu FIR i IIR, analizy i konwersji filtrów, filtrowania, transformacji,
analizy spektralnej, tworzenia okien czasowych, identyfikacji systemów i~przepróbkowywania. 

Tworzenie wykresów w GNU Octave jest możliwe przy pomocy dwóch systemów
rysujących. Domyślnie rysowanie odbywa się przy pomocy własnego systemu
wykorzystującego biblioteki graficzne \emph{QT} lub \emph{FLTK}, lecz istnieje
możliwość zmiany na inny przy pomocy polecenia
\lstinline{graphics_toolkit <nazwa systemu>}. Pozwala to wykorzystać
drugi z dostępnych systemów: gnuplot -- ten system wykorzystuje
oddzielną aplikację \emph{gnuplot}\cite{gnuplot} do rysowania. Do jej
zalet należą: szybsze rysowanie, znacznie pojemniejsza wewnętrzna
reprezentacja liczbowa (maksymalna liczba w systemie własnym nie może przekroczyć
$10^{38}$, natomiast gnuplot dopuszcza liczby aż do $10^{308}$) oraz
mniejsze wymagania sprzętowe (co jest szczególnie zauważalne przy
szczegółowych wykresach trójwymiarowych). Interfejs własny jest
upodobniony do interfejsu wykresów MATLABa, natomiast interfejs
gnuplota i jego obsługa jest mniej intuicyjna dla użytkowników
MATLABa.

Octave posiada dwa interfejsy. Pierwszym jest interfejs wiersza poleceń,
który można uruchomić wywołując komendą \lstinline{octave-cli}, posiada
on możliwości zapewniane przez bibliotekę \emph{GNU Readline}\cite{readline},
czyli edycję komend, przeszukiwanie historii komend, możliwość wklejania
i kopiowania wielu linii kodu na raz oraz uzupełnianie komend po
wciśnięciu klawisza \emph{tab}. Od wersji 3.8 istnieje również
interfejs graficzny, natomiast od wersji 4.0 jest on w pełni funkcjonalny
i uruchamia się domyślnie przy uruchomieniu aplikacji. Jest to zintegrowane
środowisko programistyczne posiadające edytor kodu źródłowego, przeglądarkę
plików, podgląd zmiennych oraz konsolę z wierszem poleceń. Istnieje również
możliwość przeglądania dokumentacji i historii komend.

Składnia języka GNU Octave jest niemalże w pełni kompatybilna ze składnią
MATLABa, choć istnieją pewne graniczne przypadki oraz różnice w działaniu
funkcji bazowych. Zaliczają się do nich: niepełne wsparcie dla klas
definiowanych przy użyciu słowa kluczowego \lstinline{classdef} oraz brak
dostępu do zmiennych zadeklarowanych w funkcji macierzystej dla funkcji
w niej zdefiniowanych. Poza tym operatory \lstinline{&} i \lstinline{|}
(operacje AND i OR na bitach zmiennych numerycznych)
w MATLABie, jeżeli są użyte w warunku zachowują się tak samo jak operatory
\lstinline{&&} i \lstinline{||} (operacje AND i OR na zmiennych logicznych),
natomiast w GNU Octave zachowują się zawsze tak samo.
Octave ponadto rozszerza nieco składnię MATLABa w celu uproszczenia i
zwiększenia czytelności i logiki języka. Komentarze można oznaczyć nie tylko
znakiem procenta (\lstinline{%}), ale również kratką (\lstinline{#}).
Cudzysłowy (\lstinline{"}) oznaczają tablice znaków tak samo jak i apostrofy
(\lstinline{'}), lecz istnieje w nich możliwość stosowania specjalnych
sekwencji takich jak \lstinline{"\n"}, czy \lstinline{"\t"}, podobnie jak w
języku C (znak nowej linii
i znak tabulatora, odpowiednio). W MATLABie cudzysłowy oznaczają
\emph{string}, typ jeszcze niezaimplementowany w Octave. Poza trzema kropkami
(\lstinline{...}), można, w celu kontynuacji instrukcji w następnej linijce,
użyć wsteczny ukośnik (\lstinline{\}). %}
By uczytelnić kod można, zamiast stosować \lstinline{end} jako zamknięcie
każdej struktury, stosować odpowiednie słowa kluczowe do każdej struktury,
czyli kończyć \lstinline{for} słowem kluczowym \lstinline{endfor} i podobnie
z innymi strukturami. Nie ma wymogu, w Octave, przypisania macierzy do
zmiennej by móc ją indeksować, można, przykładowo,  wywołać instrukcję
\lstinline{[4 3 2 1](2)}, co zwróci drugi element wektora (\lstinline{4} w
tym przypadku).
Pewne elementy składniowe zaczerpnięte są z języka C: wykrzyknik
(\lstinline{!})
oznaczający operator logiczny NOT (w MATLABie służy on do uruchamiania
poleceń powłoki systemowej), skrócone operatory inkrementacji (np.
\lstinline{++x}, oznaczający \lstinline{x = x + 1}, lub \lstinline{x += 10},
czyli \lstinline{x = x + 10}) i pętle \lstinline{do}-\lstinline{until}.

Poza różną składnią inne znaczące różnice to: wbudowane funkcje do rozwiązywania
układów równań różniczkowych, brak możliwości kompilacji skryptów do kodu
maszynowego, brak kompilacji JIT (patrz punkt \ref{sec:anaconda}), możliwość
definiowania funkcji w wierszu poleceń oraz możliwość umieszczania testów
i demonstracji w funkcji (Kod żr. \ref{tab:absoct.m}), które można następnie
uruchomić wykorzystując polecenie \lstinline{test} lub \lstinline{demo},
odpowiednio.

\begin{program}
  \caption{Funkcja licząca moduł liczby rzeczywistej w GNU Octave}
  \begin{lstlisting}
function y = modul(x)
    if x < 0
        y = -x;
    else
        y = x;
    endif
endfunction
%!test
%! assert(modul(-1),1)
  \end{lstlisting}
  \label{tab:absoct.m}
\end{program}

\section{Scilab}
\label{sec:scilab}
\lstset{language=Scilab}

Scilab\cite{Scilab} jest darmowym, otwartoźródłowym (pod licencją GPL od
wersji 6.0) pakietem obliczeniowym i skryptowym językiem programowania
do zastosowań techniczno-naukowych tworzonym przez \emph{Scilab Enterprises},
które oferuje profesjonalne wsparcie dla klientów biznesowych. Jest rozwijany
jako alternatywne rozwiązanie dla MALTABa wraz z oprogramowaniem
\emph{Xcos} -- alternatywą dla Simulinka.

Język programowania Scilab jest najmniej popularnym
językiem programowania wśród języków testowanych pakietów co utrudnia
znalezienie gotowych rozwiązań problemów i przykładów, lecz język ten
jest stosunkowo podobny do MATLABa, a Scilab zawiera narzędzie
do automatycznego tłumaczenia z jego języka. Scilab posiada w miarę
dobrą dokumentację.

Rozszerzenie możliwości Scilaba odbywa się poprzez biblioteki grupujące
funkcjonalność analogicznie do \emph{toolboxów} w MATLABie. Znajdują się
one w repozytorium \emph{ATOMS} (\emph{AuTomatic mOdules Management for Scilab}),
skąd można je pobrać wykorzystując do tego graficznego klienta uruchamianego
przez wpisanie komendy \lstinline{atomsGui} w wierszu poleceń Scilaba lub
wykorzystując do tego funkcję \lstinline{atomsInstall("<nazwa pakietu>")}.

Repozytorium ATOMS posiada niedużą liczbę bibliotek, niewiele
większą niż \emph{Octave-Forge}, ponadto większość
nie wspiera najnowszej wersji Scilaba (6.0 z lutego 2017 r.), lecz tylko
starą wersję 5.5.2 ze stycznia 2015 r. W szczególności żadna z bibliotek
związanych z przetwarzaniem sygnałów w repozytorium ATOMS nie wspiera
najnowszej wersji Scilaba. Scilab swoją funkcjonalność zawdzięcza
bogatej bibliotece podstawowej. W dziedzinie przetwarzania sygnałów pakiet
posiada funkcje do filtrowania, projektowania filtrów FIR i IIR, identyfikacji
systemów, analizy spektralnej i transformacji. Jego funkcjonalność nie jest
tak obszerna jak biblioteki \emph{signal} do GNU Octave. Aby wykorzystać
nową funkcjonalność po instalacji biblioteki nie ma konieczności
jej ładowania, gdyż dzieje się to automatycznie przy starcie aplikacji.

Scilab posiada swój własny silnik rysujący, który pozwala rysować wykresy
szybko, posiadający interfejs podobny do tego który posiada MATLAB.
Silnik ten pozwala na zapisywanie zaawansowanych formuł matematycznych
na wykresie korzystając z notacji \emph{MathML} lub \LaTeX. Scilab
wykorzystuje bibliotekę $\mathbb{J}$\LaTeX\emph{Math}, również rozwijaną
przez \emph{Scilab Enterprises}, w celu wyświetlania formuł matematycznych
w notacji \LaTeX\ -- aby tekst był zinterpretowany przez tę bibliotekę, należy
formułę otoczyć znakami dolara. Wywołanie komendy
\lstinline|title("$\sum_{i=1}^{10}\frac{1}{2^i}$")|
pozwoli otrzymać formułę $\sum_{i=1}^{10}\frac{1}{2^i}$ w tytule.

Użytkowanie Scilaba jest możliwe przy pomocy dwóch interfejsów. Jednym
z nich jest interfejs wiersza poleceń który można uruchomić ze wsparciem
dla elementów graficznych (np. rysowania wykresów) lub bez za pomocą
komendy odpowiednio \lstinline|scilab-cli| lub \lstinline|scliab-adv-cli|.
Jednak głównym interfejsem jest interfejs graficzny, wzorowany na interfejsie
MATLABa. Jest to zintegrowane środowisko programistyczne posiadające edytor
kodu źródłowego, przeglądarkę plików, inspektor zmiennych, historię komend
oraz przeglądarkę pomocy. Ciekawą cechą tego interfejsu jest możliwość
dowolnej modyfikacji ułożenia poszczególnych elementów poprzez ich
przeciąganie.

\begin{program}
  \caption{Funkcja licząca moduł liczby rzeczywistej w Scilabie}
  \centering
  \begin{lstlisting}
// plik: modul.sci
function y = modul(x)
    if x < 0
        y = -x;
    else
        y = x;
    end
endfunction
  \end{lstlisting}
  \begin{lstlisting}
//plik: skrypt.sci
exec("modul.sci");
modul(-1)
  \end{lstlisting}%$
  \label{tab:abs.sci}
\end{program}

Składnia Scilaba jest podobna do MATLABA, lecz nie jest, tak jak
GNU Octave, kompatybilna. Większość skryptów napisanych w MATLABie wymaga zmian.
Funkcje z bazowej biblioteki w większości zachowują się podobnie jak
w MATLABie, ponadto istnieje specjalna kategoria funkcji która ma za zadanie
emulować odpowiednie funkcje w MATLABie. Wśród różnic w podstawowej składni
można wymienić: zmienne wbudowane, takie jak liczba $\pi$ są poprzedzone
znakiem procenta (\lstinline|%pi|) i nie można ich nadpisać, zapobiega
to błędom w programie wynikającym z przypadkowego nadpisania stałych
matematycznych (np. użycie \lstinline|i| jako iteratora w MATLABie).
Komentarze oznacza się dwoma ukośnikami (\lstinline|//|) i nie istnieją
komentarze blokowe. Podobnie jak w GNU Octave, można kończyć definicję
funkcji słowem kluczowym \lstinline|endfunction|, lecz nie tyczy się to pozostałych
konstrukcji kontroli przepływu, które kończy się, jak w MATLABie, słowem
kluczowym \lstinline|end|. Tekst zawarty pomiędzy
cudzysłowami (\lstinline|"|) i apostrofami tak samo (\lstinline|'|) konstruuje
jednoelementową macierz z elementem typu \emph{string}. Operatory \lstinline|&|
i \lstinline{|}
oznaczają odpowiednio operacje AND i OR na zmiennych logicznych
Istnieje znacznie więcej drobnych różnic pomiędzy tymi
językami, szczególnie w działaniu funkcji wbudowanych. Istotną natomiast
różnicą jest inne zachowanie się plików. W Scilabie nie istnieje podział na
pliki ze skryptami i pliki z funkcjami, podobnie jak w Julii, Pythonie i
większości języków programowania ogólnego przeznaczenia. Wczytywanie skryptów
odbywa się poprzez funkcję \lstinline|exec("<nazwa pliku>")|, co, podobnie
jak w MATLABie wykonuje polecenia w tym pliku i udostępnia zmienne z tego
pliku w pliku macierzystym, lecz nie wywołuje funkcji w tym pliku. Aby
wywołać funkcję z innego pliku należy najpierw go wczytać i potem można
ją wywołać w zwyczajny sposób (Kod żr. \ref{tab:abs.sci}). Pozwala to swobodnie mieszać definicje
funkcji i instrukcje w skryptach Scilaba bez ograniczeń nałożonych
w MATLABie z powodu tej mechaniki.

\section{Anaconda/Python}
\label{sec:anaconda}
\lstset{language=Python}

\emph{Anaconda Distribution}\cite{Anaconda} to najpopularniejsza dystrybucja języka
programowania \emph{Python}\cite{Python} do zastosowań techniczno-naukowych,
zawiera bardzo dużą liczbę pakietów do tych celów, jest dostarczana przez
firmę Anaconda, jest otwartoźródłowa oraz darmowa. \emph{Anaconda Enterprise} jest to
wersja dystrybucji dla klientów biznesowych posiadająca pełne wsparcie
oraz większe możliwości. W dalszej części pracy \emph{Anaconda Distribution}
będzie nazywana po prostu Anaconda.

Python jest najpopularniejszym językiem programowania wśród języków badanych pakietów,
i znajduje się w pierwszej piątce najpopularniejszych języków na świecie.
Z tego powodu ilość wysokiej jakości bibliotek do tego języka jest niezwykle duża,
także niemalże każda pożądana funkcjonalność może być dodana, choć należy brać
pod uwagę, że Python w przeciwieństwie do pozostałych opisywanych języków, jest
przede wszystkim językiem ogólnego zastosowania, toteż większość dokumentacji i
bibliotek jest niezwiązana z nauką. Instalacja
bibliotek w Anacondzie odbywa się przy użyciu graficznej aplikacji
\emph{Anaconda Navigator} lub aplikacji wiersza poleceń \emph{conda}.
Używając komendy \lstinline{conda install <nazwa biblioteki>} można zainstalować
bibliotekę z repozytorium Anacondy -- \emph{Anaconda Cloud}. Jest również
możliwość instalacji bibliotek z \emph{PyPI}, czyli ogólnego zbioru bibliotek 
Pythona 
przy użyciu polecenia \lstinline{pip install <nazwa biblioteki>}. 

Aby móc wykorzystać zainstalowaną bibliotekę należy ja najpierw \emph{zaimportować},
służy do tego słowo kluczowe \lstinline{import}, po którym należy umieścić nazwę
biblioteki, po czym opcjonalnie można umieścić słowo kluczowe \lstinline{as} i
nazwę pod którą chce się aby ta biblioteka była dostępna w programie. Jeżeli
nie wykorzysta się \lstinline{as} biblioteka będzie dostępna pod swoją nazwą.
Na przykład aby zaimportować \emph{math} (bibliotekę zawierającą między innymi
stałe matematyczne) można wywołać \lstinline{import math as ma} co pozwoli
wykorzystać ją dalszej części programu pod nazwą \lstinline{ma},
na przykład wywołać \lstinline{ma.pi} w celu uzyskania liczby $\pi$.
Niektóre biblioteki, takie jak \emph{SciPy} posiadają wiele modułów,
wtedy okazuje się być koniecznym użycie słowa kluczowego \lstinline{from},
które pozwala zaimportować tylko jakiś element biblioteki, na przykład
by zaimportować tylko liczbę $\pi$ z biblioteki \emph{math} należy wywołać
\lstinline{from math import pi}, dzięki czemu aby uzyskać tę liczbę wystarczy
wywołać \lstinline{pi}.

Najważniejsze biblioteki związane z zastosowaniami techniczno-naukowymi to
są zawarte w zbiorze bibliotek tworzących ekosystem \emph{SciPy}, którego
elementarne części to Python oraz biblioteki: \emph{NumPy}, \emph{SciPy}
i \emph{matplotlib}. Ponadto w testach wykorzystano, również zawarte w
\emph{Anaconda Distribution}, biblioteki \emph{Numba} i \emph{NumExpr}.

\emph{NumPy}\cite{NumPy} jest to biblioteka, która dodaje wielowymiarowe
typy wektorowe i macierzowe, zaawansowane funkcje modyfikujące obiekty
tych typów, kolekcję funkcji matematycznych operujących na tych typach,
związanych przede wszystkim z algebrą liniową oraz transformacją Fouriera,
jak również narzędzia do integracji kodu napisanego w C/C++ oraz Fortranie.

Biblioteka \emph{SciPy}\cite{SciPy} zawiera zbiór funkcji typowo stosowanych
w pracy inżyniera i~naukowca. Są one podzielone na moduły które
kategoryzują te funkcje w grupy związane między innymi z:
optymalizacją, całkowaniem, interpolacją, funkcjami specjalnymi,
przetwarzaniem sygnałów, przetwarzaniem obrazów i rozwiązywaniem
równań różniczkowych. Zawiera ponadto alternatywne implementacje
funkcji z biblioteki \emph{NumPy} do algebry liniowej i transformacji,
które wykonują te operacje w krótszym czasie.

Za tworzenie wykresów odpowiada biblioteka \emph{matplotlib}\cite{matplotlib},
która wykorzystuje typy z biblioteki \emph{NumPy}. Oferuje ona
uproszczony interfejs (funkcję) \lstinline{pyplot()}, który pozwala
rysowań zestawy danych w sposób bardzo podobny do MATLABA. Sam \emph{matplotlib}
pozwala tylko na tworzenie wykresów dwuwymiarowych, jednak biblioteka
\emph{mplot3d} rozszerza jego funkcjonalność o możliwość
rysowania wykresów trójwymiarowych.

Biblioteki \emph{NumExpr}\cite{NumExpr} oraz \emph{NumBa}\cite{NumBa} 
służą do zwiększenia
szybkości przeprowadzanych obliczeń, choć każda osiąga to w inny sposób.
\emph{NumExpr} wykorzystuje wirtualną maszynę operującą na wektorach
by przyspieszyć operacje które przetwarzają tablice po elementach.
Architektura tej maszyny pozawala na wykorzystanie w pełni wielowątkowości
współczesnych procesorów. Maszyna wspiera operatory logiczne i arytmetyczne,
oraz część funkcji matematycznych, w tym funkcje trygonometryczne, hiperboliczne,
logarytmiczne, eksponenty i pierwiastki. Wspiera również podstawowe operacje na
liczbach zespolonych: moduł i sprzężenie. Biblioteka \emph{NumBa} natomiast
pozwala na kompilację \emph{JIT} (\emph{just-in-time}) -- zamianę na kod maszynowy
w momencie pierwszego uruchomienia tej funkcji, co w dużym stopniu przyspiesza
wykonywanie kolejnych wywołań tej funkcji, gdyż niepotrzebne jest bieżące
wykonywanie funkcji przez interpreter Pythona. Aby oznaczyć funkcję
jako cel kompilacji \emph{JIT} wystarczy przed jej definicją umieścić dyrektywę
\lstinline{@jit}.

Praca w Anacondzie jest możliwa przy pomocy trzech interfejsów. Można korzystać z
aplikacji wiersza poleceń \emph{IPython}\cite{IPython} (\emph{interactive python}), 
która zapewnia szybki dostęp do pomocy, kolorowanie składni kodu, automatyczne
podpowiedzi, historię komend, zapamiętywanie sesji oraz możliwość inspekcji
obiektów. Drugim interfejsem jest zintegrowane środowisko programistyczne
\emph{Spyder}\cite{Spyder},
przypominające wyglądem interfejs MATLABa. Integruje on w jednej aplikacji
konsolę IPythona ze wsparciem dla wyświetlania w niej wykresów, edytor
plików źródłowych,
przeglądarkę zmiennych, przeglądarkę plików oraz przeglądarkę dokumentacji.
Ostatnim interfejsem jest \emph{Jupyter}\cite{Jupyter} -- jest to specyficzne
połączenie procesora tekstu z niewielkimi możliwościami formatowania i edytora
kodu źródłowego. Dokumenty Jupytera są nazywane \emph{notatnikami} i składają się
z komórek, które mogą zwierać zwyczajny tekst, tekst formatowany w formacie \emph{Markdown}
lub kod. Każdą z tych komórek można oddzielnie uruchomić co formatuje tekst lub
wykonuje zawarty w komórce kod i wyświetla wyniki, w tym wykresy jako, element
notatnika. Pierwotnie Jupyter (wtedy jeszcze był częścią projektu \emph{IPython})
wspierał wyłącznie Pythona, lecz teraz jest on złożony z dwóch niezależnych
elementów: interfejsu webowego, który służy do edycji notatników, i jądra, które
interpretuje kod, co pozwala na wsparcie wielu innych języków.

Składnia Pythona różni się znacząco od składni języków pozostałych badanych
pakietów. Najważniejszą różnicą jest brak słów kluczowych kończących
struktury takie jak pętle, instrukcje warunkowe, czy też definicje funkcji.
W Pythonie blok kodu oznacza się wyłącznie wcięciem przed instrukcjami.
Definicję funkcji rozpoczyna słowo kluczowe \lstinline{def}
po którym następuje nazwa funkcji, lista oddzielonych przecinkami argumentów
które przyjmuje w nawiasach okrągłych i dwukropek który oznacza początek ciała
funkcji. Wszystko co następuje po tym dwukropku i ma wcięcie jest traktowane
jako ciało funkcji (przykład takiej definicji obrazuje kod źródłowy \ref{tab:abs.py}).
Drugą istotną różnicą jest indeksowanie elementów zbiorów; w Pythonie pierwszy
element zbioru ma indeks zero, czyli aby uzyskać dostęp do pierwszego elementu
listy \lstinline{lista} należy wywołać \lstinline{lista[0]}. Python wykorzystuje
kwadratowe nawiasy do indeksowania zbiorów. Język posiada dwa rodzaje pętli:
pętle \lstinline{while}, powtarzaną dopóki warunek jest spełniony oraz pętle
\lstinline{for}, która iteruje po elementach listy
(np. \lstinline{for x in range(0,10):}). Funkcje tworzące zbiory sekwencji liczb,
takie jak \lstinline{range()} nie zamieszczają górnej granicy sekwencji
w wynikowym zbiorze. Te różnice, choć znaczące, są jedynie drobnym kawałkiem
wszystkich, gdyż Python jest jedynym językiem wśród badanych który nie jest
inspirowany MATLABem.

\begin{program}
  \caption{Funkcja licząca moduł liczby rzeczywistej w Pythonie}
  \begin{lstlisting}
def modul(x):
    if x < 0:
        return -x
    else:
        return x
  \end{lstlisting}
  \label{tab:abs.py}
\end{program}

\section{JuliaPro/Julia}
\label{sec:julia}
\lstset{language=Julia}

JuliaPro\cite{JuliaPro} jest to dystrybucja języka programowania
\emph{Julia}\cite{Julia}
oferowana przez \emph{Julia Computing}, firmę zapewniającą finansowanie
i wspierającą rozwój tego języka. Zawiera ona zbiór najczęściej używanych
bibliotek oraz zintegrowane środowisko programistyczne.
Julia rozwijana jest nie tylko przez pracowników tej firmy, ale również przez
wolontariuszy będąc projektem otwartoźródłowym (pod licencją MIT). JuliaPro jest
oferowana w wersji darmowej i w wersji dla klientów biznesowych z zapewnionym
wsparciem. Julia została stworzona jako rozwiązanie problemu długiego czasu
wykonywania się programów w jeżykach interpretowanych używanych do zastosowań
techniczno-naukowych poprzez intensywne wykorzystanie kompilacji JIT (patrz punkt
\ref{sec:anaconda}).

Choć Julia jest najmłodszym z języków testowanych pakietów, pierwszy raz ukazawszy
się w 2012 roku, jest w pierwszej pięćdziesiątce najpopularniejszych języków
programowania i trzecim najpopularniejszym językiem wśród języków badanych
pakietów.
Łatwo dzięki temu znaleźć publikacje i pomoc związane z tym językiem, ponadto
Julia posiada doskonałą dokumentację.
Istnieje bardzo duża liczba bibliotek w czym Julia ustępuje tylko Pythonowi.
Odnośniki do większości bibliotek znajdują się w repozytorium git \emph{METADATA.jl}
na platformie GitHub. Aby zainstalować bibliotekę należy wykorzystać funkcję
\lstinline|Pkg.add("<nazwa pakietu>")|, co pobierze najnowszą wersję stabilną,
istnieje też możliwość pobrania biblioteki bezpośrednio z jej repozytorium git
w celu uzyskania biblioteki która nie jest zarejestrowana w 
\emph{METADATA.jl}, przy pomocy funkcji \lstinline|Pkg.clone("<adres repozytorium>")|.

Biblioteki w Julii, podobnie jak w Pythonie, są modułami, które przed użyciem
trzeba załadować. Służą do tego słowa kluczowe: \lstinline|import| i \lstinline|using|.
Polecenie \lstinline|import <nazwa modułu>| zachowuje się tak samo
jak w Pythonie (patrz punkt \ref{sec:anaconda}), natomiast
\lstinline|using <nazwa modułu>| pozwala załadować wszystkie elementy tego
modułu, co jest odpowiednikiem instrukcji 
\lstinline[language=Python]|from <nazwa modułu> import *| w Pythonie. Aby
załadować jakąś cześć modułu należy po \lstinline|using <nazwa biblioteki>| umieścić dwukropek
i wymienić elementy oddzielone przecinkiem (na przykład
\lstinline|using DSP: conv, fft|).

Julia posiada bardzo wiele bibliotek do rysowania wykresów korzystających
z wielu zewnętrznych narzędzi, takich jak gnuplot (patrz punkt \ref{sec:octave})
-- za pomocą \emph{Gaston.jl}, czy matplotlib (patrz punkt \ref{sec:anaconda}) --
za pomocą \emph{PyPlot.jl}. W pakiecie JuliaPro znajdują się biblioteki
\emph{PyPlot.jl} i \emph{Gadfly.jl}. Jako że \emph{PyPlot.jl} jest
interfejsem do modułu \lstinline{matplotlib.pyplot}, wymaga on instalacji Pythona,
wraz z tą biblioteką, by funkcjonować, co jest zapewniane przez bibliotekę
\emph{Conda.jl} -- wykorzystuje ona aplikację \emph{conda}
(patrz punkt \ref{sec:anaconda}) w celu instalacji potrzebnych bibliotek.
\emph{PyPlot.jl} wykorzystuje bibliotekę \emph{PyCall.jl}, która pozwala
rysować wykresy niemalże tak samo szybko jak w Pythonie, przekazując
tablice danych bez kopiowania. W przeciwieństwie do funkcji \lstinline|plot()|
z modułu \emph{PyPlot.jl}, której użytkowanie będzie intuicyjne dla użytkowników
tej funkcji w pakiecie MATLAB, ta funkcja w bibliotece \emph{Gadfly.jl} posiada
zupełnie inną składnie, która oparta jest na książce \emph{The Grammar of Graphics}\cite{Grammar}.

JuliaPro oferuje trzy interfejsy użytkownika. Pierwszym jest interfejs wiersza
poleceń uruchamiany poleceniem \lstinline|julia|, który zapewnia możliwość
podobne jak biblioteka GNU Readline (patrz punkt \ref{sec:octave}).
\emph{Juno}\cite{Juno}
to zintegrowane środowisko programistyczne, opierające się na edytorze \emph{Atom},
zbudowane specjalnie do użytkowania z Julią. Posiada, podobnie jak i środowiska
graficzne pozostałych pakietów, zintegrowany edytor kodu źródłowego, konsolę wiersza
poleceń Julii, przeglądarkę plików, dokumentacji i zmiennych. Ponadto posiada
dedykowany element interfejsu na wykresy. Istnieje również możliwość pisania
w Julii przy pomocy notatnika w Jupyterze (patrz punkt \ref{sec:anaconda}),
dzięki wykorzystaniu biblioteki \emph{IJulia.jl}.

Składnia Julii bierze inspiracje ze składni MATLABa, lecz jest w większości
przypadków znacznie bardzie restrykcyjna w celu zwiększenia logiki języka
oraz poprawienia efektywności kompilacji oraz, poza prostymi, funkcje nie
zachowują się kompatybilnie z odpowiednikami w MATLABie. Wśród różnic
szególnie znaczących dla użytkowników MATLABa można wymienić: indeksowanie wektorów
i macierzy odbywa się przy pomocy nawiasów kwadratowych; przypisanie
wartości tablicy do zmiennej nie kopiuje tablicy, np. po wykonaniu instrukcji
\lstinline|A = B| zmiana elementu tablicy \lstinline|A| zmieni również tablicę
\lstinline|B|, tak samo przekazanie tablicy funkcji pozwala jej modyfikować
jej elementy; dodanie nowych elementów do tablicy odbywa się przy użyciu
specjalnych funkcji (np. \lstinline|A.push!(1)| zamiast
\lstinline|A(end+1)=1|); jednostka urojona oznaczana jest \lstinline|im|;
\lstinline|[1, 2, 3]| tworzy wektor kolumnowy, gdyż przecinek służy w
takim zapisie do tworzenia tablicy, której elementami mogą być inne
tablice bez łączenia ich; instrukcja \lstinline|start:krok:koniec| tworzy
specjalny obiekt (patrz punkt \ref{sec:wynsin}); funkcje zwracają ostatnią
wartość lub wartość po słowie kluczowym \lstinline|return| (Kod żr. \ref{tab:abs.jl});
operatory logiczne, podobnie jak arytmetyczne, wymagają kropki by działać
po elemencie, a nie na całości (np. \lstinline|A .== B|). Julia posiada
znacznie silniejszy system typów niż języki pozostałych badanych pakietów,
na co szczególnie trzeba zwracać uwagę podczas wykonywania operacji matematycznych
które wymagają innego typu w wyniku, gdy funkcja zwraca liczbę
zespoloną trzeba jej podać liczbę zespoloną (np. \lstinline|log(-1+0im)| nie
\lstinline|log(-1)|). Istnieje możliwość opcjonalnej adnotacji typów zmiennych i
argumentów funkcji (Kod żr. \ref{tab:abs.jl}). Wiele elementów składni i operatorów pozwala na
pisanie bardzo krótkiego kodu, przykładowo funkcję z kodu źr. \ref{tab:abs.jl}
można zapisać w jednej linijce jako \lstinline|modul(x) = x < 0 ? -x : x|,
za pomocą matematycznej notacji funkcji i operatora
warunkowego, w stylu języka C, postaci
\lstinline|warunek ? jeżeli_prawda : jeżeli_fałsz|.

\begin{program}
  \caption{Funkcja licząca moduł liczby rzeczywistej w Julii}
  \begin{lstlisting}
function modul(x::T) where T<:Real
    if x < 0
        return -x
    else
        return x
    end
end
  \end{lstlisting}
  \label{tab:abs.jl}
\end{program}

Należy mieć na uwadze, że składnia tego języka nie jest w pełni
ukształtowana gdyż znajduje się on ciągle w fazie rozwojowej i
ulega częstym zmianom. Powoduje to, że niektóre biblioteki przestają działać
z wersji na wersje jeżeli nikt się nimi nie zajmuje. Następna
wersja Julii (0.7), natomiast, po ukończeniu będzie wersją 1.0, od której można
oczekiwać pewnej stabilności.

\chapter{Proces badawczy}
\label{chap:probad}

\section{Środowisko badawcze}
\label{sec:srodowisko}

W celu eliminacji wszelkich czynników, których występowanie mogłoby
wpłynąć na wiarygodność wyników, przygotowano minimalne środowisko
badawcze na bazie Linuxa z patchem (łatką) CONFIG\_PREEMPT\_RT
(RTLinux), gdzie RT oznacza RealTime (czasu rzeczywistego).
Pozwala on, procesowi o wysokim priorytecie, otrzymać zasoby
komputera (czas procesora, dostęp do RAMu i dysku) w pierwszej
kolejności, przed większością procesów systemowych oraz, co jest
normalnym zachowaniem Linuxa, wszystkimi procesami o niższym
priorytecie\cite{RTLinux}. Dzięki temu
można mieć pewność, że żaden proces uruchomiony w tle nie spowoduje
zaniżonych wyników badań. Testy przeprowadzono na dwóch komputerach:
laptopie z ośmiowątkowym procesorem Intel\textregistered\
Core\texttrademark\ piątej generacji i dyskiem półprzewodnikowym (SSD)
oraz komputerze stacjonarnym z~czterowątkowym procesorem AMD z serii 
Phenom\texttrademark\ II i dyskiem twardym (HDD) w~celu porównania
wyników na różnych platformach.

Wykorzystano dystrybucję \emph{Arch Linux}, gdyż posiada ona
RTLinux w repozytoriach użytkowników. Wykorzystana wersja
Linuxa to 4.14.8 z patchem w wersji 9. Wykorzystane wersje
pakietów to:
\begin{itemize}%
\item Anaconda 5.01/Python 3.6.3
\item GNU Octave 4.2.1
\item JuliaPro v0.6.1.1/Julia v0.6.1
\item MATLAB R2017b
\item Scilab 6.0 (Wersja z systemu CI z 29.11.2017)
\end{itemize}%
Są to najnowsze stabilne wersję tych pakietów na dzień 29.11.2017,
poza Scilabem, którego wersja stabilna nie uruchamia się na tej
wersji Linuxa. Jest to problem w wersji 6.0, który nie został
jeszcze naprawiony. Ponadto oficjalne odnośniki do pobrania
wersji \emph{nightly} zwracają błąd 404, toteż jedyną opcją było
pobranie wersji z systemu CI (Continuous Integration -- system
automatycznej kompilacji i testowania kodu). Dodatkowo, jako że
pakiet JuliaPro nie zawiera w sobie biblioteki pozwalającej
odczytywać pliki audio, wykorzystano, wybraną ze względu na
popularność, bibliotekę \emph{WAV.jl} w wersji v0.9.0.

Do zbadania sposobu wykorzystywania zasobów komputera przez procesy 
pakietów obliczeniowych wykorzystano aplikację \emph{htop}, a do
przetwarzania i analizy danych wynikowych testów wykorzystano język
\emph{R}.

\section{System testujący}
\label{sec:systest}

Został napisany automatyczny system testujący pakiety w celu
wygodnego powtarzania testów. Składa się on z skryptu w bashu
(powłoka systemowa w większości systemów opartych na Linuxie),
który zajmuje się uruchamianiem pakietów, interpretuje
przyjmowane argumenty i przekazuje opcje do pakietów, oraz
ze skryptów w każdym z testowanych języków, które uruchamiają
testy, mierzą czas wykonania, po czym zapisują wyniki do pliku.
\begin{program}%
\caption{Funkcja \lstinline|testdir()|}%
\lstinputlisting[language=bash, firstline=25, lastline=54]{../tests/test.sh}%
\label{tab:testdir}%
\end{program}%
Najważniejszą częścią skryptu testującego jest funkcja \lstinline{testdir()}
(Kod żr. \ref{tab:testdir}),
która przyjmuje trzy argumenty: \emph{\$1} -- ścieżka do pakietu
testowanego, \emph{\$2} -- rozszerzenie plików pakietu oraz \emph{\$3} --
nazwa folderu w którym znajdują się testy. Testy muszą znajdywać
się w~podfolderach i zawierać się w pliku \emph{test.\$2}. Struktura tego
pliku jest omówiona w punkcie \ref{sec:algo}, natomiast rysunek
\ref{fig:dirstruc} pokazuje jak powinna wyglądać struktura
folderów.
\begin{figure}[h]%
  \centering%
  \begin{minipage}{0.3\textwidth}%
    \dirtree{%
      .1 tests/.
      .2 test.sh.
      .2 matlab/.
      .3 tester.m.
      .3 tests/.
      .4 sin/.
      .5 test.m.
      .4 fft/.
      .5 test.m.
      .4 \dots.
      .2 julia/.
      .3 \dots.
      .2 \dots.
    }%
  \end{minipage}%
  \caption{Struktura folderów systemu testującego}%
  \label{fig:dirstruc}%
\end{figure}%
\begin{program}%
  \caption{Fragment pliku testującego (Julia)}%
  \lstinputlisting[language=Julia, firstline=8, lastline=17]{../tests/julia/tester.jl}%
  \label{tab:tester}%
\end{program}%
Funkcja \lstinline{testdir()} uruchamiana jest dla każdego z pakietów
z odpowiednimi argumentami, ponadto w pliku \emph{test.sh},
znajduje się tablica z globalnymi ustawieniami, które zostają
zapisane w pliku \emph{options.\$2} i następnie wczytane przez
kod testujący w testowanym języku w pliku \emph{tester.\$2}
(Kod źr. \ref{tab:tester}). Skrypt \emph{test.sh} można uruchomić
z trzema argumentami, kolejno: nazwa folderu z testami
(nazwa pakietu), nazwa testu (folderu z plikiem \emph{test.\$2})
i maksymalny rząd wielkości ilości elementów wektora wejściowego.
Argumenty pierwszy i drugi przekazywane są do funkcji \lstinline{testdir()} jako
odpowiednio \lstinline{$3} i \lstinline{$TESTARG}, natomiast zmienna
\lstinline{$INPUT_SIZES} %$
zawiera szereg kolejnych potęg liczby dziesięć,
aż do maksymalnego rzędu wielkości ilości elementów wektora wejściowego.
Skrypt uruchamia każdy z pakietów za pomocą komendy \lstinline{chrt},
nadając najwyższy priorytet ich procesom, wszystkie pakiety
uruchamiane są bez interfejsu graficznego w celu zmniejszenia
czasu startowego i pominięcia jego wpływu na wydajność pakietu.
Plik testujący \emph{tester.\$2} pomija wynik pierwszego
testu by uwzględnić \emph{prekompilację} -- w celu przyspieszenia
wykonywania instrukcji część pakietów kompiluje napisany skrypt do
postaci kodu maszynowego, co może powodować nadmiarowo długi czas
wykonywania się funkcji za pierwszym razem. Każde uruchomienie
funkcji testowanej zawarte jest pomiędzy wywołaniami funkcji
mierzących czas systemowy: są to \lstinline{tic()} i \lstinline{toc()}
w MATLABie, GNU Octave i Scilabie, \lstinline{tic()} i
\lstinline{toq()} w Julii, natomiast
w Pythonie wywoływane jest \lstinline{tic=time.time()} i
\lstinline{time.time()-tic}. Po wykonaniu
odpowiedniej ilości testów (ilość ustalana jest w pliku
\emph{test.sh} i następnie przekazywana do pliku \emph{options.\$2}
jako zmienna \lstinline{number_of_tests})
zapisuje wyniki do pliku w formacie HDF5\cite{hdf5}.
Jest to binarny format zapisu danych liczbowych w postaci
macierzy wielowymiarowych, który jest obsługiwany przez
wszystkie pakiety (do GNU Octave wymagana jest dodatkowa
biblioteka \emph{hdf5oct}) i zawiera informację o strukturze, przypominającej
foldery i pliki. Wynik dla każdego rzędu wielkości zapisany jest
w oddzielnej tablicy, nazwanej numerem oznaczającym rząd wielkości,
w grupie \emph{/<test>/<pakiet>/} (Rys. \ref{fig:h5struc}).
\begin{figure}[h]%
  \centering%
  \begin{minipage}{0.3\textwidth}%
    \dirtree{%
      .1 /.
      .2 sin/.
      .3 matlab/.
      .4 1.
      .4 2.
      .4 \dots.
      .3 julia/.
      .4 \dots.
      .3 \dots.
      .2 fft/.
      .3 \dots.
      .2 \dots.
    }%
  \end{minipage}%
  \caption{Struktura wyników w pliku HDF5}%
  \label{fig:h5struc}%
\end{figure}%


\section{Badane funkcje i algorytmy}
\label{sec:algo}

Zbadano pięć funkcji, cztery biblioteczne i jedną własną.
Starano się wybrać funkcję które są koniecznym elementem 
budulcowym w aplikacjach przetwarzających sygnały dźwiękowe.
Każdy test znajduje się w jednym pliku w którym muszą
znajdywać się funkcje: \lstinline{prepare_input()} -- 
przygotowuje dane wejściowe dla testowanej funkcji, jako
argument przyjmuje ilość elementów wektora danych,
\lstinline{test_function()} -- testowana funkcja, przyjmuje
dane przygotowane przez funkcję \lstinline{prepare_input()},
przetwarza je i zwraca wynik. W kolejnych punktach zostaną
opisane pokrótce te testy wraz z przykładowym kodem
w~jednym z testowanych języków. Jeśli nie jest napisane
inaczej, to w testach w Pythonie korzystano z funkcji
z biblioteki \emph{NumPy}.

\subsection{Sinus}
\label{sec:sin}

Jako pierwszą zbadano, jedną z najbardziej podstawowych
funkcji matematycznych, jaką jest sinus. Jest to najprostszy
test, funkcja przygotowująca dane
tworzy tablicę punktów rozmieszczonych w równych odległościach
pomiędzy $0$, a $2\pi$, natomiast funkcja testowana wywołuje
funkcję \lstinline{sin()} na tych danych (Kod źr. \ref{tab:sintest}).
W teście dla pakietu \emph{Anaconda} wykorzystano bibliotekę
\emph{numexpr} (Patrz punkt \ref{sec:anaconda}).

\begin{program}%
  \caption{Test funkcji \lstinline|sin()| (Python)}%
  \lstinputlisting[language=Python, firstline=3]{../tests/python/tests/sin/test.py}%
  \label{tab:sintest}%
\end{program}%

\subsection{FFT}
\label{sec:fft}

FFT (Fast Fourier Transform) jest niezwykle istotnym algorytmem w analizie
sygnałów audio, pozwala wykonać dyskretną transformatę
Fouriera w znacznie krótszym czasie niż algorytm naiwny.

\subsubsection{Funkcja biblioteczna}
\label{sec:fftbib}

Danymi wejściowymi jest sygnał audio, będący sumą dwóch
sinusów o~częstotliwościach \SI{50}{\hertz} i \SI{120}{\hertz}
oraz szumu białego, o częstotliwości próbkowania \SI{1}{\kilo\hertz}.
Funkcja testowana wywołuje na tym sygnale funkcję \lstinline{fft()}
(Kod źr. \ref{tab:ffttest}). Kod testu oparty jest na dokumentacji
funkcji \lstinline{fft()} dla pakietu MATLAB. W pakiecie \emph{Anaconda} jest
dostępnych kilka implementacji FFT, wykorzystano tę której wyniki
były najlepsze -- \lstinline{fftpack.fft()} z biblioteki \emph{SciPy}. 
Natomiast w Julii zastosowano dyrektywę
\lstinline{FFTW.set_num_threads(Sys.CPU_CORES)}, która pozwala
wykorzystać wszystkie dostępne wątki procesora do obliczeń,
znacznie przyspieszając obliczenia, zgodnie z zaleceniami
z~dokumentacji.

\begin{program}%
  \caption{Test funkcji \lstinline|fft()| (Python)}%
  \lstinputlisting[language=Python, firstline=2]{../tests/python/tests/fft/test.py}%
  \label{tab:ffttest}%
\end{program}%

\subsubsection{Algorytm własny}
\label{sec:fftwla}

Ważnym elementem użytkowania pakietów obliczeniowych jest
tworzenie własnych procedur, gdyż nie wszystkie
potrzebne funkcje są zawsze w bibliotekach. Aby przetestować
jak dobrze dany pakiet jest w stanie zoptymalizować
ręcznie stworzoną procedurę, napisano w każdym z języków
dokładnie tę samą funkcję. Funkcją tą jest procedura FFT
\lstinline{four1()} opisana w
\emph{Numerical Recipes in C}\cite{Recipes}
(oparta na procedurze opisanej przez N. M. Brennera), przepisana
z języka C do jeżyków testowanych pakietów oraz zaadaptowana do
korzystania z natywnych typów liczb zespolonych, które
występują we wszystkich badanych pakietach. Dane wejściowe
są identyczne jak w punkcie \ref{sec:fftbib}, lecz, jako że
ta procedura operuje tylko na tablicach, których rozmiar
jest potęgą liczby dwa, są one wydłużane do odpowiedniego
rozmiaru, jako nowe elementy wstawiając zera.

Procedura \lstinline{four1()} (Zał. \ref{chap:zalfour1}) implementuje algorytm
Cooleya-Tukeya i składa się z~dwóch sekcji. Pierwsza sekcja
to pętla która zamienia miejscami elementy wektora
wejściowego w taki sposób, że gdyby ponumerować wszystkie
elementy wektora wejściowego od zera rosnąco w systemie dwójkowym, to po
zamianach ta numeracja była by malejąca, w tym celu zamieniane
są elementy wektora wejściowego które są swoim odbiciem lustrzanym
(np. 001 i 100). Druga sekcja jest pętlą, która
wykonuje się $log_2N$ razy (gdzie $N$ to długość wektora
wejściowego) w której dwie wewnętrzne pętle
wymnażają odpowiednio elementy poprzednich transformat
obliczając nową, o dwa razy większym rozmiarze. 
Zgodnie z definicja, każdy z elementów wektora jest jednopunktową
transformatą Fouriera, które następnie łączy się w transformaty
o długościach $2, 4, 8, \dots, N$, stosując lemat
Danielsona-Lanczosa (\ref{eq:lanczos}). 
\begin{equation}%
  F_k=F^e_k+e^{-2k\pi i/N}F^o_k
  \label{eq:lanczos}
\end{equation}%
gdzie%
\begin{eqwhere}[2cm]%
\item[$F_k$] $k$-ty punkt dyskretnej transformaty Fouriera
\item[$F_k^e$] $k$-ty punkt elementów transformaty o parzystym indeksie
\item[$F_k^o$] $k$-ty punkt elementów transformaty o nieparzystym indeksie
\item[$N$] ilość punktów dyskretnej transformaty Fouriera
\end{eqwhere}%
  
\subsection{Splot}
\label{sec:splot}
  
Splot jest istotną operacją dla przetwarzania sygnałów,
gdyż pozwala on stosować filtry (FIR, IIR), oraz symulować
wpływ środowisk akustycznych na sygnał poprzez splecenie
ich odpowiedzi impulsowych z sygnałem. Funkcja testowana
wywołuje splot na dwóch tablicach z wartościami losowymi
(Kod źr. \ref{tab:convtest}).

\begin{program}%
  \caption{Test funkcji \lstinline|conv()| (MATLAB/GNU Octave)}%
  \lstinputlisting[language=MATLAB, firstline=6]{../tests/matlab/tests/conv/test.m}%
  \label{tab:convtest}%
\end{program}%

\subsection{Wczytywanie pliku audio}
\label{sec:wavread}

Aby móc sygnał poddać obróbce należy go najpierw wczytać
do pamięci pakietu. W przypadku dużych plików, wczytywanie
może być stosunkowo długim procesem. Aby to przetestować
funkcja przygotowująca tworzy plik w formacie WAV, z
częstotliwością próbkowania \SI{48}{\kilo\hertz} i
rozdzielczością bitową \SI{16}{\bit}, o odpowiedniej liczbie
próbek, natomiast funkcja testowana wczytuje go do pamięci
(Kod źr. \ref{tab:wavreadtest}).
\begin{program}%
  \caption{Test funkcji \lstinline|wavread()| (Scilab)}%
  \lstinputlisting[language=Scilab, firstline=3]{../tests/scilab/tests/wavread/test.sci}%
  \label{tab:wavreadtest}%
\end{program}%

\chapter{Wyniki testów}
\label{chap:wyniki}

Do przetwarzania danych wynikowych wykorzystano biblioteki
\emph{reshape2} i \emph{dplyr}, natomiast
wykresy stworzono za pomocą biblioteki \emph{ggplot2}.
Na wykresie oznaczono medianę czasu wykonania procedury
testowanej oraz przedział od wartości minimalnej do
maksymalnej dla \SI{95}{\percent} najmniejszych wyników.
Pominięto \SI{5}{\percent} najwyższych wyników z powodu
ich nieporównywalnie wysokiej wartości, powodującej 
znaczne zmniejszenie czytelności wykresów. Ponieważ tego typu
wyniki, których wartość była ponad dwa razy wyższa niż
wartość średnia występowały dla wszystkich pakietów, uznano
że są one spowodowane tymczasowym niedoborem lub
spowolnieniem zasobów przez nie wykorzystywanych albo
uruchomieniem \emph{GC} (\emph{Garbage Collector} --
jest to pewna część języka programowania, która
zajmuje się oczyszczaniem pamięci ze zmiennych,
do których nie ma już odnośników w programie).

Każdy test wywoływał funkcję testowaną
\num{\Sexpr{length(results.intel$fft$octave[1,])}}
razy co
pozwoliło zminimalizować wpływ losowych czynników
niepożądanych na wyniki. Kolejne punkty zawierają
wykresy z wynikami oraz ich interpretację. W punkcie
\ref{sec:sum} znajduje się podsumowanie wyników w postaci
średniej ważonej wyników dla każdego rozmiaru wektora
wejściowego, gdzie wagą jest ten rozmiar.


\section{Sinus}
\label{sec:wynsin}

Jak można zauważyć (Rys. \ref{fig:sin.intel} i \ref{fig:sin.amd}),
zastosowanie biblioteki \emph{NumExpr} w Pythonie,
pozwala obliczyć sinus dla dużych w wektorów wejściowych,
znacznie szybciej w~Anacondzie, w czasie średnio o
\SI{\Sexpr{percentFaster(results.intel$sin, "matlab", "python")}}{\percent} %$
krótszym niż MATLAB.
Różnica jest mniejsza w~przypadku komputera stacjonarnego,
prawdopodobnie z powodu mniejszej ilości wątków procesora
(\SI{\Sexpr{percentFaster(results.amd$sin, "matlab", "python")}}{\percent}). %$
MATLAB jest drugi pod względem czasu wykonywania procedury
wykonując funkcję \lstinline{sin()} w średnio o
\SI{\Sexpr{percentFaster(results.intel$sin, "julia", "matlab")}}{\percent} %$
krótszym czasie niż Julia.
(\SI{\Sexpr{percentFaster(results.amd$sin, "julia", "matlab")}}{\percent} %$
dla AMD). Różnice pomiędzy Julią a GNU Octave i Scilabem są niewielkie
(\SI{\Sexpr{percentFaster(results.intel$sin, "octave", "julia")}}{\percent} %$
dla Intela i 
\SI{\Sexpr{percentFaster(results.amd$sin, "octave", "julia")}}{\percent} %$
dla AMD)
W Julii funkcje takie jak \lstinline{linspace()}, lub
konstrukcje \lstinline{start:step:end} nie tworzą całych
tablic, ale specjalne obiekty których elementy są wyliczane
dopiero, gdy jest wymagany do nich dostęp,
pozwala to przyspieszyć operacje, które nie wykorzystują
wszystkich wartości z wektora, natomiast w przypadku tego testu
działa to na niekorzyść, gdyż z~każdym wywołaniem funkcji
\lstinline{sin.()} muszą być wyliczone wszystkie elementy
wektora wejściowego. Używając funkcji \lstinline{collect()}
można zamienić te obiekty na wektory. Z przeprowadzonych
krótkich testów wynikło jednak, że wpływ tego jest stosunkowo
niewielki, na poziomie \SI{10}{\percent}.

<<sin.intel, fig.cap="Wyniki testu funkcji \\lstinline{sin()} (Laptop/Intel)">>=

preparePlot(results.intel$sin)

@ 

<<sin.amd, fig.cap="Wyniki testu funkcji \\lstinline{sin()} (PC/AMD)">>=

preparePlot(results.amd$sin)

@ 

\section{FFT}
\label{sec:wynfft}

\subsection{Funkcja biblioteczna}
\label{sec:wynfftbib}

Wyniki testu funkcji \lstinline{fft()} są o tyle ciekawe,
że wszystkie pakiety, poza Anacondą, wykorzystują bibliotekę
\emph{FFTW}\cite{FFTW} (skrót pochodzi od
\emph{Fastest Fourier Transform in the West}) -- jest to jedna
z naszybszych bibliotek liczących transformatę Fouriera, napisana
głownie w C. Nie jest ona używana przez \emph{SciPy} z powodu
niekompatybilnych licencji, lecz istnieje możliwość wykorzystania
\emph{FFTW} w Pythonie wykorzystując bibliotekę \emph{PyFFTW}. Nie
zawiera się ona jednak w podstawowej dystrybucji Anacondy, toteż
jej nie wykorzystano do testów, choć mogłaby ona zmniejszyć
czas obliczeń. Każdy z pakietów wykorzystuje własną wersję \emph{FFTW}
z pewnymi modyfikacjami, które potrafią poprawić wydajność,
ponadto \emph{FFTW} pozwala na wykorzystanie tzw. \emph{planowania FFT}
-- jest to proces w którym biblioteka wstępnie oblicza macierz
transformacji dla danego rozmiaru FFT, co pozwala znacznie
przyspieszyć obliczanie kolejnych FFT o tym samym rozmiarze
po prostu mnożąc sygnał przez tę macierz. To, oraz fakt, że
\emph{FFTW} pozwala modyfikować wiele parametrów algorytmu
obliczania FFT, powoduje że różnice, choć nie bardzo duże,
istnieją (Rys. \ref{fig:fft.intel} i \ref{fig:fft.amd}.

Najkrócej oblicza GNU Octave w czasie średnio o
\SI{\Sexpr{percentFaster(results.intel$fft, "matlab", "octave")}}{\percent} %$
krótszym niż MATLAB, o~%
\SI{\Sexpr{percentFaster(results.intel$fft, "julia", "octave")}}{\percent} %$
krótszym niż Julia, o
\SI{\Sexpr{percentFaster(results.intel$fft, "python", "octave")}}{\percent} %$
krótszym niż Python i o
\SI{\Sexpr{percentFaster(results.intel$fft, "scilab", "octave")}}{\percent} %$
krótszym niż Scilab (odpowiednio
\SI{\Sexpr{percentFaster(results.amd$fft, "matlab", "octave")}}{\percent}, %$
\SI{\Sexpr{percentFaster(results.amd$fft, "julia", "octave")}}{\percent}, %$
\SI{\Sexpr{percentFaster(results.amd$fft, "python", "octave")}}{\percent} i %$
\SI{\Sexpr{percentFaster(results.amd$fft, "scilab", "octave")}}{\percent} %$
dla AMD).

<<fft.intel, fig.cap="Wyniki testu funkcji \\lstinline{fft()} (Laptop/Intel)">>=

preparePlot(results.intel$fft)

@ 

<<fft.amd, fig.cap="Wyniki testu funkcji \\lstinline{fft()} (PC/AMD)">>=

preparePlot(results.amd$fft)

@ 

\subsection{Algorytm własny}
\label{sec:wynfftwla}

Jak widać na wykresach (Rys. \ref{fig:four1.intel} i \ref{fig:four1.amd}),
funkcja \lstinline{four1()} nie jest ani trochę tak
wydajna jak algorytmy biblioteczne, lecz nie to było jej
celem. Dzięki porównaniu szybkości tej funkcji można zobaczyć jak
dobrze sobie radzi każdy z pakietów z optymalizacją
kodu napisanego przez użytkownika. Algorytm funkcji testowanej
(opis w punkcie \ref{sec:fftwla})
zawiera dużo pętli i nie stosuje \emph{wektoryzacji} kodu --
czyli używania funkcji operujących na wektorach zamiast
korzystania z pętli. Praktyka \emph{wektoryzacji} jest
zalecana w badanych językach, za wyjątkiem Julii,
lecz wymaga ona większej wprawy, toteż należy brać pod uwagę
że testowany kod nie jest optymalny pod względem wydajności,
natomiast jest on dobrym przykładem kodu napisanego na szybko
w celu przetestowania jakiejś idei.
Jako że stosowany algorytm jest bardzo prosty i nie
stosuje żadnych zaawansowanych technik optymalizacji
FFT różnice pomiędzy pakietami są niemalże identyczne
dla każdego z rozmiarów wektora wejściowego. Z tego
samego powodu nie ma też dużych różnic pomiędzy
wynikami z laptopa i komputera stacjonarnego.

Użycie biblioteki \emph{NumBa} (patrz punkt \ref{sec:anaconda}) pozwala uzyskać Pythonowi
najlepszy czas w tym teście, obliczając FFT, w czasie o
\SI{\Sexpr{percentFaster(results.amd$four1, "julia", "python")}}{\percent} %$
krótszym niż Julia, o
\SI{\Sexpr{percentFaster(results.intel$four1, "matlab", "python")}}{\percent} %$
krótszym niż MALTAB (odpowiednio
\SI{\Sexpr{percentFaster(results.amd$four1, "julia", "python")}}{\percent}, %$
\SI{\Sexpr{percentFaster(results.amd$four1, "matlab", "python")}}{\percent}, %$
dla AMD).
To są niesamowicie duże różnice i ukazują potencjał
jaki mają Python i Julia jako narzędzia do szybkiego prototypowania.
MATLAB jest trzeci pod względem szybkości i ma znaczną
przewagę nad resztą pakietów obliczając FFT w czasie o
\SI{\Sexpr{percentFaster(results.intel$four1, "scilab", "matlab")}}{\percent} %$
krótszym niż Scilab i o
\SI{\Sexpr{percentFaster(results.intel$four1, "octave", "matlab")}}{\percent} %$
krótszym niż GNU Octave (odpowiednio
\SI{\Sexpr{percentFaster(results.amd$four1, "scilab", "matlab")}}{\percent} i %$
\SI{\Sexpr{percentFaster(results.amd$four1, "octave", "matlab")}}{\percent} %$
dla AMD).

<<four1.intel, fig.cap="Wyniki testu funkcji \\lstinline{four1()} (Laptop/Intel)">>=

preparePlot(results.intel$four1)

@ 

<<four1.amd, fig.cap="Wyniki testu funkcji \\lstinline{four1()} (PC/AMD)">>=

preparePlot(results.amd$four1)

@ 

\section{Splot}
\label{sec:wynsplot}

Wyniki testów funkcji \lstinline{conv()}, są niezwykle
interesujące (Rys. \ref{fig:conv.intel} i \ref{fig:conv.amd}),
gdyż występują tu różnice pomiędzy pakietami, sięgające nawet czterech
rzędów wielkości.
Szczególnie wyróżnia się Julia wykonując splot w czasie o
\SI{\Sexpr{percentFaster(results.intel$conv, "matlab", "julia")}}{\percent} %$
krótszym niż MATLAB (%
\SI{\Sexpr{percentFaster(results.amd$conv, "matlab", "julia")}}{\percent} %$
dla AMD). Ta duża różnica jest spowodowana wykorzystaniem
algorytmu splotu wykorzystującego FFT
(patrz następny akapit).
MATLAB za to splata w czasie o~%
\SI{\Sexpr{percentFaster(results.intel$conv, "python", "matlab")}}{\percent} %$
krótszym niż Python na laptopie, natomiast w czasie tylko o
\SI{\Sexpr{percentFaster(results.amd$conv, "python", "matlab")}}{\percent} %$
krótszym na komputerze stacjonarnym, gdyż tam
kod w Pythonie wykonuje się szybciej niż na laptopie. Może to wskazywać
na niewykorzystanie przez algorytm wielowątkowości
procesora, co spowodowało lepszy wynik na wyżej taktowanym
procesorze AMD.
Od Scilaba MATLAB wykonuje splot o
\SI{\Sexpr{percentFaster(results.intel$conv, "scilab", "matlab")}}{\percent} %$
krócej, natomiast od GNU Octave o
\SI{\Sexpr{percentFaster(results.intel$conv, "octave", "matlab")}}{\percent} %$
krócej (%
\SI{\Sexpr{percentFaster(results.amd$conv, "scilab", "matlab")}}{\percent} i %$
\SI{\Sexpr{percentFaster(results.amd$conv, "octave", "matlab")}}{\percent} %$
dla AMD).

<<conv.intel, fig.cap="Wyniki testu funkcji \\lstinline{conv()} (Laptop/Intel)">>=

preparePlot(results.intel$conv)

@ 

\begin{program}
\caption{Implementacja splotu FFT w MATLABie/GNU Octave}
\begin{lstlisting}[language=MATLAB]
function Y = fftconv(X1, X2)
    pad1 = zeros(1, length(X2) - 1);
    pad2 = zeros(1, length(X1) - 1);
    Y = abs(ifft(fft([X1 pad1]).*fft([X2 pad2])));
end
\end{lstlisting}
\label{tab:fftconv}
\end{program}

Algorytm stosowany przez badane pakiety, za wyjątkiem
Julii, opiera się najprawdopodobniej na definicji
splotu, nie jest to jednak
najefektywniejsze rozwiązanie, gdyż jest możliwe
obliczenie splotu za pomocą FFT. Należy w tym celu
wydłużyć oba wektory wejściowe o odpowiednią ilość
zer, tak by oba miały długość równą sumie długości
wektorów wejściowych mniej jeden. Następnym krokiem
jest zamiana obu wektorów na dziedzinę częstotliwości,
poprzez FFT, wymnożenie transformat z obu sygnałów i
wykonanie odwrotnego FFT na sygnale wynikowym (Kod źr.
\ref{tab:fftconv} przedstawia przykładową implementację).
Ten algorytm korzysta z faktu, że splot w dziedzinie
czasu równy jest mnożeniu w dziedzinie częstotliwości.
Czas wykonania takiej procedury będzie zbliżony do
czasu potrzebnego na wykonanie trzech operacji FFT,
krótkie testy pokazały ponad stukrotnie krótszy
czas wykonania tej procedury w GNU Octave od procedury
bibliotecznej dla dużych wektorów wejściowych.
Ta procedura jest zaimplementowana w bibliotece
\emph{SciPy} jako \lstinline{signal.fftconvolve()}.

<<conv.amd, fig.cap="Wyniki testu funkcji \\lstinline{conv()} (PC/AMD)">>=

preparePlot(results.amd$conv)

@ 

\section{Wczytywanie pliku audio}
\label{sec:wynwavread}

Jak obrazują wykresy (Rys. \ref{fig:wavread.intel} i \ref{fig:wavread.amd})
biblioteka \emph{WAV.jl} w Julii jest wyjątkowo
nieefektywna we wczytywaniu plików dłuższych niż około \SI{0.2}{\second},
w istocie GNU Octave wczytuje pliki w czasie o
\SI{\Sexpr{percentFaster(results.intel$wavread, "julia", "octave")}}{\percent} %$
krótszym niż Julia (%
\SI{\Sexpr{percentFaster(results.amd$wavread, "julia", "octave")}}{\percent} %$
na HDD). Scilab również
odbiega od reszty pakietów, GNU Octave wczytuje w czasie o
\SI{\Sexpr{percentFaster(results.intel$wavread, "scilab", "octave")}}{\percent} %$
krótszym od niego (%
\SI{\Sexpr{percentFaster(results.amd$wavread, "scilab", "octave")}}{\percent} %$
dla HDD).
Od MATLABa ani od Pythona, GNU Octave nie jest dużo szybsze,
bo wczytuje tylko w odpowiednio o
\SI{\Sexpr{percentFaster(results.intel$wavread, "matlab", "octave")}}{\percent} %$
i o
\SI{\Sexpr{percentFaster(results.intel$wavread, "python", "octave")}}{\percent} %$
krótszym czasie niż te pakiety (%
\SI{\Sexpr{percentFaster(results.amd$wavread, "matlab", "octave")}}{\percent} %$
i
\SI{\Sexpr{percentFaster(results.amd$wavread, "python", "octave")}}{\percent} %$
na HDD). Interesujący jest brak znaczących różnic pomiędzy
wynikami z laptopa z wykorzystaniem znacznie szybszego
dysku typu SSD, a komputerem stacjonarnym z dyskiem HDD.
Wskazuje to na pomijalny wpływ prędkości dysku na
wczytywanie plików audio w tych pakietach, a istniejące
różnice pomiędzy wynikami z laptopa i PC, spowodowane
są prawdopodobnie wolniejszym procesorem i pamięcią RAM.


Należy wspomnieć, że \emph{WAV.jl} nie jest jedyną
biblioteką do wczytywania plików \emph{wav}, choć jest
to biblioteka najpopularniejsza oraz jest ona wykorzystywana
przez bibliotekę \emph{FileIO} oferującą zunifikowany
interfejs do wczytywania wszelkiego rodzaju plików.
Jedną z alternatyw jest biblioteka \emph{LibSndFile.jl},
która korzysta z biblioteki \emph{libsndfile} napisanej
w C. Krótkie testy wykazały dziewięciokrotnie
krótszy czas wczytywania przy wykorzystaniu tej biblioteki.


<<wavread.intel, fig.cap="Wyniki testu funkcji \\lstinline{wavread()} (Laptop/SSD)">>=

preparePlot(results.intel$wavread)

@ 

<<wavread.amd, fig.cap="Wyniki testu funkcji \\lstinline{wavread()} (PC/HDD)">>=

preparePlot(results.amd$wavread)

@ 

\section{Sumaryczne zestawienie wyników}
\label{sec:sum}

Patrząc na wykresy (Rys. \ref{fig:summary.intel} i \ref{fig:summary.amd})
można zaobserwować, że nie ma jednego pakietu, którego
zastosowanie w każdej sytuacji pozwoli uzyskać wyniki w
najkrótszym możliwym czasie. W każdym z wykonanych testów inne
pakiety wykonały testowaną funkcję najszybciej, a inne najwolniej.

Jednym wyjątkiem jest Scilab który wykonał każdy z testów
w~najdłuższym (w~dwóch przypadkach) lub drugim od końca (w
trzech przypadkach) czasie. Choć nie było przypadku w którym
czas ten był najdłuższy i jednocześnie oddalony o kilka rzędów
wielkości od większości wyników, nie stawia go to na dobrej
pozycji.

MATLAB jest na bardzo silnej pozycji będąc drugim najszybszym
pakietem, w~czterech, i posiadając środkowy wynik, w~jednym, teście.
Jest to narzędzie, którego zastosowanie w każdej sytuacji będzie
pozwalało stosunkowo szybko
wykonać potrzebne obliczenia jest więc dobrym wyborem na każdą
okazję, lecz do każdego z zadań znajdzie się szybsza alternatywa,
na przykład jeżeli celem jest napisanie algorytmu który będzie
w~dużym stopniu wykorzystywał pętle, lepiej skorzystać z Pythona.

Anaconda jest doskonałą alternatywą dla MATLABa, gdyż, pod względem
prędkości tylko w testach funkcji \lstinline{conv()} i \lstinline{fft()},
nieznacznie mu ustępuje.
Zastosowanie rozwiązań opisanych w 
punktach \ref{sec:wynfft} i \ref{sec:wynsplot} może pozwolić
dodatkowo zwiększyć szybkość tych funkcji
pomniejszając różnice jeszcze bardziej.

Również dobrą alternatywą jest Julia, która w dwóch testach
wykonała funkcje szybciej
(\lstinline{conv()} i \lstinline{four1()}), szczególnie,
wykonując splot w czasie dwa rzędy wielkości krótszym niż MATLAB. W dwóch,
natomiast, wolniej (\lstinline{sin()} i \lstinline{fft()}),
co stawiałoby ją na dobrej pozycji gdyby nie bardzo wolne
wykonanie testu wczytywania plików \emph{wav}, w~czasie dłuższym o prawie
dwa rzędy wielkości. W punkcie \ref{sec:wynwavread} opisano podejście które
częściowo rozwiązuje ten problem.

GNU Octave jest o tyle ciekawym przypadkiem, że w testach
funkcji \lstinline{fft()} i~\lstinline{wavread()} wypada
lepiej niż MATLAB, choć różnice są zaledwie na poziomie
około \SI{20}{\percent} lecz w testach \lstinline{conv()}
i \lstinline{four1()} wykazuje niezwykle długi czas
obliczeń, w porównaniu z najszybszym pakietem, o około
trzy rzędy wielkości dłuższy.
W teście \lstinline{sin()} jest na ostatnim miejscu
\emph{ex æquo} z Scilabem. Jedno z rozwiązań na wolne wykonywanie
się splotu zostało opisane w punkcie \ref{sec:wynsplot},
lecz tak zły wynik w teście \lstinline{four1()} jest
poważną przeszkodą do wykorzystania tego pakietu jako
narzędzie do szybkiego prototypowania aplikacji
przetwarzających sygnały audio.

Nie zauważono znacznych różnic pomiędzy wynikami z
laptopa i PC, poza oczywistymi dłuższymi czasami
na PC spowodowanymi wolniejszym procesorem. Jednym
wyjątkiem jest test funkcji \lstinline{conv()}
w którym test w Pythonie wykonał się
szybciej na komputerze stacjonarnym niż na
laptopie. Mimo tego można uznać, że wyniki są w niewielkim
zależne od rodzaju procesora, a ich duże podobieństwo
sugeruje powtarzalność.

<<summary.intel, fig.cap="Średnia ważona wyników testów (Laptop)">>=
summaryPlot(results.intel)

@ 

<<summary.amd, fig.cap="Średnia ważona wyników testów (PC)">>=
summaryPlot(results.amd)

@ 
\chapter{Podsumowanie}
\label{chap:podsumowanie}

\section{Wnioski końcowe}
\label{sec:sumanaliza}

Przeprowadzone badania wykazały, że niektóre z badanych
pakietów potrafią wykonać pewne zadania w czasie do kilku
rzędów wielkości krótszym, co może spowodować porównywalną różnice
w czasie obliczeń skomplikowanych algorytmów korzystających
z~tej funkcjonalności pakietu. Takie różnice w czasie
wykonywania są poważnym powodem do zastanowieniem się nad
użyciem innego pakietu. Dominująca pozycja MATLABa w~środowisku
naukowym jest mocno zagrożona przez pakiet Anaconda, którego
prędkość stała niemalże na tym samym poziomie jeśli nie wyższym,
a funkcjonalność
na bardzo wysokim z powodu dużej ilości bibliotek. Natomiast
dla osób zaznajomionych z MATLABem, składnia Pythona
może być zbyt obca, by szybko uzyskać wprawę w tym języku.
Julia posiada składnię znacznie
bliższą MATLABowi, zapewniając podobną prędkość obliczeń i
dużą ilość bibliotek,
choć problematycznie długi czas wczytywania plików audio
i niewielką zgodność w użytkowaniu funkcji. Niemalże pełną
zgodność zapewnia GNU Octave, choć dwa testy
wykonało w czasie o trzy rzędy wielkości dłuższym, a ilość
bibliotek jest stosunkowo niewielka. Scilab
natomiast nie posiada, zdaje się, żadnej przewagi nad
którymkolwiek z pozostałych pakietów będąc jednym z ostatnich
w każdym teście, posiadając mało bibliotek i nie będąc zgodnym
językowo z MATLABem.

\section{Dalsze kierunki badań}
\label{sec:kier}

W tej pracy zbadano zaledwie kilka funkcji, które,
choć podstawowe, nie pokazują pełnego obrazu wydajności pakietów,
także w dalszych
badaniach można powiększyć zakres badanych funkcji. W szczególności
można zbadać najczęściej używane funkcje z~%
\emph{Singal Processing Toolbox} i ich odpowiedniki w pozostałych
pakietach, jak również można podjąć badania innych pakietów.
Skonstruowany na potrzeby tej pracy system testujący pozwala na
zrobienie tych badań ze stosunkową łatwością. Ponadto można w
dalszych badaniach podjąć się porównania
prędkości badanych pakietów do języków C i~Fortran, które nie są
interpretowane i których czas wykonywania powinien być zbliżony do
możliwie najkrótszego na danym sprzęcie. W badaniach podjęto
się testów wyłącznie przy użyciu systemu GNU/Linux oraz zbadano
wyłącznie komputery z procesorami o~architekturze \emph{x86}.
W dalszych badaniach można się podjąć badań na innych architekturach
(ARM, RISC-V, \dots) oraz innych systemach operacyjnych
(Microsoft Windows, BSD, \dots). Pozwoli to uzyskać znacznie szerszy
obraz działania pakietów obliczeniowych i~efektywności technik
optymalizacji obliczeń przez nie stosowanych.


% Bibliografia

% Odnośniki do umieszczenia w bibl:
% https://docs.anaconda.com/
% https://docs.julialang.org/
% https://www.anaconda.com/enterprise/
% https://matplotlib.org/citing.html
% citation() w GNU Octave

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliografia}
\printbibliography

% Załączniki
\begin{appendices}
  \makeatletter%
  \addtocontents{toc}{\let\protect\l@chapter\protect\l@section}
  \makeatother%

  \chapter{Kod funkcji {\ttfamily four1()} (Julia)}
  \label{chap:zalfour1}
  {\singlespacing\lstinputlisting[language=Julia, firstline=13]{../tests/julia/tests/four1/test.jl}}
\end{appendices}

\end{document}
